\documentclass[12pt,a4paper,openright,twoside]{book}
\usepackage[utf8]{inputenc}
\usepackage{disi-thesis}
\usepackage{code-lstlistings}
\usepackage{notes}
\usepackage{shortcuts}
\usepackage{acronym}
\usepackage{placeins}

\school{\unibo}
\programme{Corso di Laurea in Ingegneria e Scienze Informatiche}
\title{Prompt-to-Action: un Model Context Protocol per l’integrazione real-time con configuratori 3D}
\author{Latini Luca}
\date{\today}
\subject{Computer Graphics}
\supervisor{Prof. Damiana Lazzaro}
\cosupervisor{Dott. Christian Lillini}
%\morecosupervisor{Dott. CoSupervisor 2}
\session{I}
\academicyear{2025-2026}

% Definition of acronyms (keys in lowercase)
\acrodef{mcp}[\textit{MCP}]{\textit{Model Context Protocol}}
\acrodef{llm}[\textit{LLM}]{\textit{Large Language Model}}
\acrodef{api}[\textit{API}]{\textit{Application Programming Interface}}
\acrodef{lsp}[\textit{LSP}]{\textit{Language Server Protocol}}
\acrodef{ide}[\textit{IDE}]{\textit{Integrated Development Environment}}
\acrodef{ai}[\textit{AI}]{\textit{Artificial Intelligence}}
\acrodef{http}[\textit{HTTP}]{\textit{HyperText Transfer Protocol}}

\mainlinespacing{1.241} % line spacing in mainmatter, comment to default (1)

\begin{document}

\frontmatter\frontispiece

\begin{abstract}	
Il presente lavoro di tesi descrive la progettazione e realizzazione di un prototipo di \ac{mcp} volto a consentire il controllo e la configurazione di un configuratore grafico 3D mediante l’uso di prompt testuali. L’obiettivo principale è stato definire e implementare un meccanismo che traduca comandi descritti in linguaggio naturale nella chiamata automatica degli strumenti appropriati e nell’esecuzione delle operazioni corrispondenti all’interno del configuratore. Il sistema è realizzato in C\# e si articola in moduli per la gestione del contesto, l’invocazione dei tool e la comunicazione in tempo reale con il client grafico tramite WebSocket. Il lavoro comprende l’analisi dei requisiti, la progettazione dell’architettura software, l’implementazione dei moduli principali e la validazione funzionale tramite scenari di test. I risultati dimostrano la fattibilità del paradigma prompt\(\rightarrow\)tool per operazioni di gestione progetto nel configuratore, evidenziando punti di forza e limiti attuali in termini di robustezza semantica, gestione degli errori e scalabilità. Come contributo si propone un prototipo funzionante e linee guida per future estensioni, quali la gestione multi-utente.
\end{abstract}

\begin{dedication} % this is optional
Optional. Max a few lines.
\end{dedication}

%----------------------------------------------------------------------------------------
\tableofcontents   
\listoffigures     % (optional) comment if empty
\lstlistoflistings % (optional) comment if empty
%----------------------------------------------------------------------------------------

\mainmatter

%----------------------------------------------------------------------------------------
\chapter{Introduzione}
\label{chap:introduction}
%----------------------------------------------------------------------------------------

%Write your intro here.
%\sidenote{Add sidenotes in this way. They are named after the author of the thesis}

%You can use acronyms that your defined previously,
%such as \ac{IoT}.
%
%If you use acronyms twice,
%they will be written in full only once
%(indeed, you can mention the \ac{IoT} now without it being fully explained).
%
%In some cases, you may need a plural form of the acronym.
%
%For instance,
%that you are discussing \acp{vm},
%you may need both \ac{vm} and \acp{vm}.
\section{Contesto Aziendale e Motivazione del Progetto}
\label{sec:contesto-aziendale}
Il lavoro descritto in questa tesi è stato svolto nell'ambito di un tirocinio presso \textbf{Apra S.p.A.}, una software house attiva da oltre 40 anni nello sviluppo di soluzioni IT per la trasformazione digitale delle imprese. Apra opera in ambiti quali Cloud Computing, Big Data, Digital Experience, Mobile, Business Analytics, Internet of Things e Industria 4.0, collaborando con importanti produttori di tecnologie informatiche e offrendo soluzioni e consulenza per l'ottimizzazione dei processi aziendali.

Durante il tirocinio sono stato inserito nel team Ricerca e Sviluppo, impegnato nell'identificazione di idee innovative per migliorare la connettività e l'orchestrazione tra servizi AI e applicazioni aziendali. Il team ha manifestato particolare interesse nel valutare la fattibilità dell'integrazione tra server MCP e un front-end specializzato, in questo caso un configuratore grafico 3D, ambito ancora poco esplorato ma potenzialmente rilevante per i flussi di lavoro aziendali.

L'obiettivo principale del tirocinio è stato esplorativo: verificare come un Model Context Protocol possa essere efficacemente integrato con un configuratore 3D e definire una possibile roadmap tecnica per un'adozione futura. Il lavoro si è focalizzato sulla prototipazione e sulla valutazione di pattern di integrazione (server MCP \(\leftrightarrow\) bridge realtime \(\leftrightarrow\) client 3D), con particolare attenzione a vincoli operativi quali autenticazione, sincronizzazione realtime, robustezza semantica dei comandi e requisiti di sicurezza. Il risultato atteso non è una soluzione definitiva, ma un insieme di evidenze tecniche, criteri di fattibilità e raccomandazioni operative per gli sviluppi successivi (ad es. integrazione di moduli NLP, supporto multi-utente, politiche di auditing e scalabilità).

Nel contesto dell'attività svolta, due componenti fondamentali erano già presenti in azienda:
\begin{itemize}
  \item un bridge realtime basato su SignalR, che funge da canale di comunicazione bidirezionale;
  \item un configuratore grafico 3D (client), responsabile del rendering e dell'interazione con i modelli.
\end{itemize}
Il mio compito è stato quindi di utilizzare questi elementi esistenti come base: sviluppare un prototipo di MCP server, creare il canale bidirezionale tramite il bridge SignalR e adattare il client grafico affinché possa stabilire la connessione, interpretare i messaggi in ingresso e applicare le azioni richieste.

\section{Obiettivi della tesi}
\label{sec:obiettivi}
Obiettivo generale: progettare e realizzare un prototipo operativo di Model Context Protocol che permetta il controllo di un configuratore 3D tramite prompt testuali, valutando la fattibilità tecnica dell'integrazione realtime e definendo una roadmap per un'eventuale industrializzazione.

Obiettivi specifici e misurabili:
\begin{itemize}
  \item Implementare il core MCP in C\# e definire il meccanismo di mapping prompt\,\(\rightarrow\)\,tool 
  \item Integrare e sfruttare il bridge realtime esistente basato su SignalR/WebSocket per stabilire un canale bidirezionale tra MCP server e client grafico. 
  \item Adattare il configuratore grafico esistente affinché possa connettersi a SignalR, ricevere e interpretare i messaggi dal MCP e invocare le funzioni appropriate per aggiornare la vista 3D.
  \item Fornire o migliorare, se necessario, un'interfaccia utente per l'invio di prompt e la visualizzazione dello stato, front-end in Svelte.
  \item Definire e verificare almeno \textbf{10} scenari end-to-end (ad es.: creazione progetto, aggiunta componente, apertura riga di progetto, consultazione catalogo).
  \item Documentare il processo di integrazione e consegnare un kit di riproducibilità (README aggiornato, file di esempio, script di avvio) che spieghi come replicare l'integrazione MCP \(\leftrightarrow\) SignalR \(\leftrightarrow\) client 3D.
\end{itemize}

Ambito e vincoli:
\begin{itemize}
  \item Incluso: integrazione del MCP con il bridge SignalR esistente, adattamento del client grafico per la gestione dei messaggi, implementazione del mapping prompt\(\rightarrow\)tool, prototipazione e test funzionali/integrativi.
  \item Escluso: sviluppo di un nuovo engine SignalR o riscrittura completa del configuratore 3D; implementazione di NLP avanzato per interpretazione libera del linguaggio (si adotta un insieme di prompt strutturati/templati).
\end{itemize}
\chapter{Background}
\label{chap:background}
\section{La Crisi della Frammentazione nell'Ecosistema AI}
Modelli Linguistici di Grande Scala (\acs{llm}) sono diventati centrali nell'Intelligenza Artificiale (\ac{ai}) moderna, dimostrando capacità straordinarie nella comprensione e generazione del linguaggio naturale \cite{mcp_survey_kent}, e alimentando agenti autonomi che operano in ambienti cloud, edge e desktop\cite{mcp_survey_kent}. Questi agenti sono cruciali per automatizzare compiti complessi ed eseguire azioni interagendo con servizi o strumenti esterni.\cite{mcp_karimova_analysis}

Nonostante i rapidi progressi nel ragionamento degli LLM, essi rimangono intrinsecamente vincolati dalla dipendenza da dataset di addestramento statici, limitando la loro applicabilità in scenari dinamici e in tempo reale \cite{mcp_survey_aditi}. Tradizionalmente, l'integrazione degli LLM con sistemi esterni si è basata su interfacce di programmazione (\ac{api}) frammentate e costruite su misura.\cite{mcp_survey_kent}

Questa mancanza di standardizzazione crea una crisi di frammentazione\cite{mcp_survey_transport}, ostacolando la scalabilità, la sicurezza e la generalizzazione della comunicazione tra agenti guidati dagli LLM\cite{mcp_survey_kent}. Le integrazioni ad-hoc comportano una duplicazione dello sforzo di sviluppo, aumentano la complessità, e introducono inconsistenze di sicurezza\cite{mcp_survey_aditi}. Per ottenere flussi di lavoro multi-agente modulari, riutilizzabili e resilienti, l'interoperabilità,la capacità dei sistemi distinti di scoprire capacità, scambiare contesto e coordinare azioni in modo fluido, è considerata essenziale.\cite{mcp_survey_kent}

\section{Definizione e Ruolo del Model Context Protocol (MCP)}
\label{sec:mcp-definition}
Per rispondere a questa esigenza sistemica di standardizzazione, Anthropic ha introdotto \ac{mcp}, lanciato nel novembre 2024\cite{mcp_anthropic_launch}. L'MCP è uno standard open-source progettato per connettere le applicazioni \ac{ai} a sistemi esterni.\cite{mcp_doc_whatis}
L'MCP è stato descritto metaforicamente come una "porta USB-C per l'AI". Proprio come USB-C standardizza la connettività dei dispositivi, l'MCP fornisce un modo universale per le applicazioni AI di accedere a dati e strumenti.\cite{mcp_doc_whatis}
Il suo obiettivo principale è standardizzare il modo in cui le applicazioni forniscono contesto agli LLM, sostituendo le integrazioni frammentate con un protocollo unico e universale. Questo approccio mira a sbloccare l'integrazione sicura e strutturata tra i sistemi \ac{ai} e le risorse esterne, migliorando l'efficacia dei modelli fornendo risposte più pertinenti. L'MCP si inserisce in una linea evolutiva di standardizzazione dei protocolli, simile al successo ottenuto dalle \ac{api} e dal \ac{lsp} nei rispettivi domini.\cite{mcp_doc_whatis}

\subsection{Architettura e Componenti Centrali}
\label{subsec:sicurezza-autenticazione}
L'MCP si basa su un'architettura client-server persistente che facilita l'interazione strutturata tra LLM e risorse esterne. I partecipanti chiave sono:

\begin{itemize}
\item \textbf{MCP Host:} L'applicazione \ac{ai} (ad esempio, Claude Desktop o un \ac{ide}) che gestisce l'esperienza utente complessiva e coordina uno o più Client MCP. L'Host funge da contenitore per l'LLM e ha la responsabilità di orchestrare le connessioni. Gestisce il consenso dell'utente per l'accesso ai dati e l'esecuzione di azioni, e aggrega il contesto proveniente da più client per fornirlo al modello.\cite{mcp_doc_arch}

\item \textbf{MCP Client:} Un componente che mantiene una connessione dedicata uno-a-uno con un Server MCP per ottenere il contesto da utilizzare. Il client agisce come un traduttore, convertendo le richieste dell'LLM (spesso sotto forma di chiamate a funzioni) nel formato del protocollo MCP e, viceversa, trasformando le risposte del server in un formato comprensibile per l'LLM. È anche responsabile della scoperta e dell'utilizzo dei server disponibili.\cite{mcp_doc_arch}

\item \textbf{MCP Server:} Il programma che espone le capacità, fornendo dati, servizi e template al Client. I Server MCP possono essere eseguiti sia localmente (ad esempio, tramite il trasporto Stdio) che remotamente (ad esempio, tramite Streamable \ac{http}).Ogni server si concentra su un punto di integrazione specifico, promuovendo la riutilizzabilità e la manutenibilità\cite{mcp_doc_arch}
\end{itemize}

L'MCP è composto da due strati concettualmente distinti:\cite{mcp_survey_aditi}

\begin{itemize}
\item \textbf{Livello Dati (Data Layer):} Definisce l'interazione basata sulla specifica JSON-RPC 2.0. Questo livello include la gestione del ciclo di vita (lifecycle management) per la negoziazione delle capacità e i primitives.\cite{mcp_doc_arch}

\item \textbf{Livello Trasporto (Transport Layer):} Gestisce la trasmissione fisica dei messaggi \cite{mcp_survey_kent}. Supporta lo Stdio (per la comunicazione locale tra processi con prestazioni ottimali e senza network overhead) e Streamable \ac{http} (che utilizza \ac{http} POST per i messaggi client-server, con opzionali Server-Sent Events per lo streaming e supporto per autenticazione standard \ac{http} come token o OAuth).\cite{mcp_doc_arch}
\end{itemize}
 I \textbf{primitives} sono il concetto più importante dell'MCP e definiscono il modo in cui i server possono condividere contesto con le applicazioni \ac{ai}.

I server espongono tre componenti principali:

\begin{itemize}
\item \textbf{Tools (Strumenti):} Capacità controllate dal modello (Model-controlled) che l'LLM può invocare per eseguire azioni, chiamate \ac{api} o query di database. L'LLM decide quando utilizzare questi strumenti basandosi sulle richieste dell'utente.\cite{mcp_doc_servers}

\item \textbf{Resources (Risorse):} Fonti di dati controllate dall'applicazione (Application-controlled) che forniscono dati strutturati e in sola lettura per arricchire il contesto. Le risorse sono identificabili tramite URI unici (ad esempio, \texttt{file:///path/to/document.md}).\cite{mcp_doc_servers}

\item \textbf{Prompts (Template):} Template riutilizzabili e parametrizzati controllati dall'utente (User-controlled) per definire pattern di interazione consistenti e strutturare flussi di lavoro complessi.\cite{mcp_doc_servers}
\end{itemize}

\subsection{ Ruolo dell'MCP nell'Evoluzione dell'AI e Vantaggi Chiave}
L'MCP è una tecnologia fondamentale per l'evoluzione verso l'Agentic AI, fornendo meccanismi standardizzati che permettono agli agenti autonomi di accedere a dati in tempo reale e compiere azioni dinamiche.

Oltre ai primitives del server, l'MCP definisce anche primitives che il Client espone ai server, consentendo interazioni bidirezionali più ricche:

\begin{itemize}
\item \textbf{Sampling:} Consente ai server di richiedere al client l'esecuzione di inferenza (completamenti) da parte dell'LLM, rendendo i server indipendenti dal modello AI specifico e mantenendo il controllo umano (human-in-the-loop) e la sicurezza sul lato client.
\end{itemize}
\begin{figure}[!htbp]
  \centering
  \includegraphics[width=.8\linewidth]{figures/Sampling.png}
  \caption{Architettura del primitive Sampling nel \ac{mcp} che mostra il ciclo di richiesta–inferenza–approvazione tra client, server e utente umano.\cite{mcp_doc_clients}}
  \label{fig:sampling}
\end{figure}

\FloatBarrier

\begin{itemize}
\item \textbf{Elicitation:} Permette ai server di richiedere input specifici o una conferma all'utente (ad esempio, per finalizzare una prenotazione).

\end{itemize}
\begin{figure}[!htbp]
  \centering
  \includegraphics[width=.8\linewidth]{figures/Elicitation.png}
  \caption{Architettura del primitive Elicitation nell'MCP che mostra il ciclo di richiesta-interazione umana-risposta tra Server, Client e utente.\cite{mcp_doc_clients}}
\label{fig:Elicitation}
\end{figure}

\FloatBarrier

\begin{itemize}
\item \textbf{Roots:} Meccanismo di coordinamento che definisce i confini logici o gli scope operativi, spesso per percorsi di filesystem, per guidare i server su quali risorse concentrarsi.
\end{itemize}

L'adozione dell'\ac{mcp} porta vantaggi significativi nell'ecosistema \ac{ai}:

\begin{itemize}
\item \textbf{Standardizzazione e Riutilizzabilità:} Riduce la complessità e il tempo di sviluppo\cite{mcp_doc_whatis}, permettendo agli sviluppatori di riutilizzare il codice di integrazione attraverso diverse applicazioni AI.\cite{mcp_karimova_analysis}

\item \textbf{Sicurezza e Trasparenza:} Implementa schemi standardizzati per l'autenticazione, l'autorizzazione e l'audit, garantendo coerenza e riducendo i rischi associati agli approcci ad-hoc.\cite{mcp_survey_aditi}\cite{mcp_karimova_analysis}

\item \textbf{Composability e Scalabilità:} Promuove un design modulare che supporta la scalabilità indipendente dei componenti (server e client). Inoltre, la composability permette ai nodi di funzionare sia come client che come server, facilitando la creazione di catene di agenti complesse e gerarchiche.\cite{mcp_survey_aditi}\cite{mcp_karimova_analysis}

\item \textbf{Roadmap di Adozione:} L'MCP è visto come un passo iniziale e cruciale in una roadmap di adozione graduale dei protocolli AI, fungendo da base per l'accesso agli strumenti prima di protocolli più complessi come ACP, A2A e ANP.\cite{mcp_survey_kent}
\end{itemize}
\section{WebSocket: Protocollo per Comunicazione Real-Time}
\label{sec:websocket-protocollo}
%----------------------------------------------------------------------------------------

% NUOVA SEZIONE - Contenuto teorico compatto (1-1.5 pagine)
%
% Contenuti da sviluppare:
%
% A) Introduzione WebSocket (0.5 pagine):
% - RFC 6455: standard IETF per comunicazione bidirezionale full-duplex
% - Problema risolto: limitazioni HTTP polling (overhead, latenza, scalabilità)
% - Handshake HTTP Upgrade: transizione da HTTP a protocollo WebSocket
% - Connessione persistente su TCP: mantiene socket aperto per comunicazione continua
%
% B) Caratteristiche Protocollo (0.5 pagine):
% - Full-duplex: client e server inviano messaggi contemporaneamente
% - Low-latency: no overhead header HTTP ripetuti (frame leggeri)
% - Message-oriented: supporto frame text (UTF-8) e binary
% - Keep-alive: ping/pong frames per mantenere connessione attiva
%
% C) Vantaggi WebSocket (0.25 pagine):
% - Performance: riduzione latenza 50-80% vs HTTP long polling
% - Scalabilità: minor overhead rete, meno connessioni simultanee
% - Real-time bidirectional: server push senza polling client
% - Supporto browser: standard nativo (Chrome, Firefox, Safari, Edge)
%
% D) Limitazioni Protocollo (0.25 pagine):
% - No fallback automatico: se WebSocket non supportato, connessione fallisce
% - Riconnessione manuale: developer deve implementare retry logic
% - Gestione stato: server deve tracciare connessioni attive (memory overhead)
% - Sicurezza: richiede WSS (WebSocket Secure su TLS) per traffico cifrato
% - Cross-origin: CORS deve essere configurato correttamente
%
% E) Collegamento con il Progetto (breve paragrafo):
% - WebSocket è fondamento per SignalR (astrazione high-level)
% - Progetto usa SignalR invece di WebSocket raw per produttività e robustezza
% - Dettagli implementativi SignalR in Cap. 3 Stack Tecnologico
%
% NO code snippet (protocollo standard, teoria)
%
% Elementi visivi OPZIONALI:
% - Diagramma handshake HTTP → WebSocket upgrade
% - Tabella confronto HTTP polling vs WebSocket (latenza, overhead, scalabilità)
%
% Pagine stimate: 1-1.5

%----------------------------------------------------------------------------------------
\section{Configuratori 3D: Panoramica e Contesto}
\label{sec:configuratori-3d}
%----------------------------------------------------------------------------------------

% Questa sezione introduce il concetto di configuratori 3D e il loro ruolo nel progetto,
% fornendo contesto per comprendere le sfide dell'integrazione AI-3D.

%----------------------------------------------------------------------------------------
\subsection{Cosa sono i Configuratori 3D}
\label{subsec:cosa-sono-configuratori}
%----------------------------------------------------------------------------------------

I configuratori 3D sono applicazioni software interattive che permettono agli utenti di personalizzare prodotti complessi (mobili, cucine, interni, veicoli) visualizzando in tempo reale il risultato in un ambiente tridimensionale.

\paragraph{Caratteristiche Principali:}

\begin{itemize}
\item \textbf{Rendering 3D Real-Time:} Utilizzo di tecnologie WebGL, Three.js, Unity o Unreal Engine per rendering interattivo nel browser o desktop

\item \textbf{Parametrizzazione Prodotti:} Gestione di cataloghi con migliaia di articoli, ognuno con parametri (dimensioni, colori, finiture, accessori)

\item \textbf{Regole di Configurazione:} Engine che valida combinazioni valide (es. scaffale larghezza 80cm compatibile solo con ante specifiche)

\item \textbf{Calcolo Prezzi Dinamico:} Aggiornamento in tempo reale del prezzo totale in base a configurazione corrente

\item \textbf{Esportazione Dati:} Generazione documenti tecnici (preventivi, distinte materiali, disegni CAD)
\end{itemize}

\paragraph{Architettura Tipica:}

\begin{itemize}
\item \textbf{Frontend:} Interfaccia utente per selezione prodotti e visualizzazione 3D
\item \textbf{Backend:} API REST per catalogo prodotti, salvataggio progetti, calcolo prezzi
\item \textbf{Engine 3D:} Libreria rendering (Three.js, Babylon.js) che gestisce scene, luci, telecamere
\item \textbf{Database:} Catalogo prodotti con geometrie 3D (mesh, texture) e metadati
\end{itemize}

%----------------------------------------------------------------------------------------
\subsection{Casi d'Uso e Applicazioni}
\label{subsec:casi-uso-configuratori}
%----------------------------------------------------------------------------------------

I configuratori 3D sono utilizzati in diversi settori:

\begin{itemize}
\item \textbf{Arredamento e Interior Design:} Configurazione cucine, soggiorni, uffici (es. IKEA Home Planner, Nolte Küchen)

\item \textbf{Automotive:} Personalizzazione veicoli con optional, colori, interni (es. BMW Individual, Porsche Car Configurator)

\item \textbf{Architettura e Edilizia:} Progettazione spazi, scelta materiali, visualizzazione render

\item \textbf{Manufacturing B2B:} Configurazione macchinari industriali, impianti, sistemi modulari

\item \textbf{E-commerce Premium:} Prodotti custom (gioielli, biciclette, abbigliamento su misura)
\end{itemize}

\paragraph{Vantaggi per Clienti:}

\begin{itemize}
\item Visualizzazione realistica del prodotto finale prima dell'acquisto
\item Maggiore coinvolgimento (engagement) e riduzione incertezza
\item Esplorazione illimitata di varianti senza vincoli fisici showroom
\item Decisioni più consapevoli, riduzione resi
\end{itemize}

\paragraph{Vantaggi per Aziende:}

\begin{itemize}
\item Riduzione errori ordine (configurazione validata da engine)
\item Automazione processo preventivazione
\item Raccolta dati su preferenze clienti (analytics configurazioni)
\item Differenziazione competitiva (esperienza utente premium)
\end{itemize}

%----------------------------------------------------------------------------------------
\subsection{Sfide dell'Integrazione AI-3D}
\label{subsec:sfide-integrazione-ai-3d}
%----------------------------------------------------------------------------------------

L'integrazione di AI conversazionale (LLM) con configuratori 3D presenta sfide uniche che motivano questo lavoro di tesi:

\paragraph{Sfide Tecniche:}

\begin{enumerate}
\item \textbf{Mapping Linguaggio Naturale \(\rightarrow\) Comandi Strutturati:}
   - Input AI: "Aggiungi uno scaffale bianco largo 80 cm"
   - Output Configuratore: \texttt{AddArticle(cod: "SP80", params: \{col: "bianco", l: 800\})}
   - Necessità di interpretare dimensioni, colori, posizioni in formato strutturato

\item \textbf{Sincronizzazione Stato:}
   - Configuratore mantiene stato progetto (articoli aggiunti, prezzi)
   - AI deve avere visibilità su stato corrente per suggerimenti contestuali
   - Necessità di notifiche bidirezionali per aggiornamenti real-time

\item \textbf{Gestione Vincoli e Validazioni:}
   - Configuratore ha regole complesse (compatibilità, fisica, pricing)
   - AI potrebbe suggerire configurazioni invalide se non consapevole vincoli
   - Necessità di feedback loop: AI propone \(\rightarrow\) Configuratore valida \(\rightarrow\) AI adatta

\item \textbf{Latenza e User Experience:}
   - Utente si aspetta feedback istantaneo su comandi vocali/testuali
   - Catena AI inference + API calls + rendering 3D deve essere <1-2 secondi
   - Necessità di comunicazione real-time (WebSocket) invece di polling

\item \textbf{Multimodalità:}
   - Utente può interagire sia tramite AI che manualmente nel configuratore
   - Necessità di sincronizzare azioni manuali con contesto AI
   - Conflitti potenziali: utente modifica manualmente, AI non ne è consapevole
\end{enumerate}

\paragraph{Sfide Architetturali:}

\begin{itemize}
\item \textbf{Disaccoppiamento:} Configuratore 3D e MCP Server sono sistemi indipendenti, necessità di bridge (SignalR)

\item \textbf{Protocolli Eterogenei:} MCP usa JSON-RPC, Configuratore usa REST, necessità di traduzione

\item \textbf{Autenticazione Cross-System:} JWT token deve essere valido per MarkunoAPI, SignalR e Configuratore

\item \textbf{Error Handling Distribuito:} Failure può avvenire in MCP, SignalR, MarkunoAPI o Configuratore, necessità di propagazione errori end-to-end
\end{itemize}

\paragraph{Contributo di Questa Tesi:}

Questo lavoro affronta le sfide sopra attraverso:
\begin{itemize}
\item Progettazione di un'architettura dual-channel (REST + SignalR) per sincronizzazione real-time
\item Implementazione di pattern GET-MODIFY-SAVE per operazioni atomiche complesse
\item Definizione di tool MCP semanticamente ricchi per mapping linguaggio naturale
\item Gestione robusta errori con partial success e messaggi user-friendly
\item Validazione end-to-end con 10+ scenari di test
\end{itemize}
%\paragraph{Structure of the Thesis}
WebSocket è uno standard (\textit{RFC6455}) per comunicazione bidirezionale full-duplex su connessione TCP persistente \cite{gourko_websocket_thesis}. Una volta stabilita (tramite handshake HTTP), client e server possono inviare messaggi in entrambe le direzioni senza chiusure continue, riducendo l’overhead tipico delle richieste HTTP tradizionali. Questo consente aggiornamenti in tempo reale con bassa latenza e alto throughput \cite{gourko_websocket_thesis}\cite{websocket_adoption_www21}. Ad esempio, WebSocket è ampiamente usato in applicazioni chat, giochi online, dashboard finanziari e servizi di localizzazione in cui servono flussi di dati continui \cite{gourko_websocket_thesis}\cite{websocket_adoption_www21}. Altri vantaggi includono il supporto nativo dei browser moderni (nessun plugin aggiuntivo) e la possibilità di inviare dati binari, riducendo i costi di encoding/decoding rispetto a HTTP/1.0. Inoltre, non è necessario ricaricare la pagina o fare polling ripetuto per ricevere nuovi dati.

Tuttavia, i WebSocket presentano limiti. L’implementazione lato server è più complessa: ogni connessione richiede risorse di memoria e CPU per rimanere attiva\cite{gourko_websocket_thesis}. In scenari con molti utenti simultanei, questo può diventare un collo di bottiglia di scalabilità. A livello di sicurezza, è necessario usare sempre WSS (WebSocket sicuro) su TLS per cifrare il traffico\cite{gourko_websocket_thesis}\cite{websocket_adoption_www21}; in caso contrario, la connessione rimane vulnerabile a intercettazioni. Gli stessi WebSocket non hanno meccanismi automatici di riconnessione né controllo del flusso; questi devono essere gestiti manualmente dall’applicazione. Infine, aspetti di sicurezza come l’autenticazione e la validazione dell’origin devono essere implementati con attenzione, poiché errori possono esporre a rischi come XSS/CSRF\cite{gourko_websocket_thesis}
%----------------------------------------------------------------------------------------
%----------------------------------------------------------------------------------------
\chapter{Stack Tecnologico}
\label{chap:stack-tecnologico}
%----------------------------------------------------------------------------------------

% OBIETTIVO DEL CAPITOLO:
% Fornire le conoscenze tecniche essenziali per comprendere le scelte architetturali
% del progetto. Focus su COSA sono le tecnologie principali, PERCHÉ sono state scelte
% e QUALI caratteristiche le rendono determinanti.
%
% APPROCCIO:
% - Spiegazioni concise e mirate (NO manuali completi)
% - Confronti con alternative (solo tabelle comparative)
% - Motivazioni tecniche chiare
% - Esempi concettuali (NO dettagli implementativi)
%
% SEPARAZIONE DELLE RESPONSABILITÀ:
% - Cap. 3 (questo): COSA/PERCHÉ - conoscenze tecnologiche (12-15 pagine)
% - Cap. 4 (Progettazione): COME architettura - design patterns, diagrammi
% - Cap. 5 (Implementazione): COME codice - classi, metodi, configurazioni

%----------------------------------------------------------------------------------------
\section{Panoramica dello Stack}
\label{sec:panoramica-stack}
%----------------------------------------------------------------------------------------

% Contenuti da sviluppare (2 pagine):
%
% A) Visione d'insieme dello stack (0.7 pagine):
% - Organizzazione per layer funzionali:
%   * Backend Platform: .NET 8 LTS + C# 12 + ASP.NET Core
%   * Communication Layer: SignalR + WebSocket + REST + JSON-RPC 2.0
%   * Security Layer: JWT (RFC 7519) + CORS + HTTPS/WSS
%   * Frontend Integration: TypeScript 5.x + @microsoft/signalr
%
% B) Criteri di selezione tecnologica (0.6 pagine):
% - **Modernità**: stack aggiornato 2023-2024 con supporto LTS
% - **Performance**: throughput elevato per real-time (<10ms latency)
% - **Type-safety**: tipizzazione statica end-to-end (.NET ↔ TypeScript)
% - **Ecosistema**: librerie mature, documentazione completa, community attiva
% - **Interoperabilità**: compatibilità nativa con MCP Protocol (JSON-RPC)
% - **Manutenibilità**: pattern consolidati, tooling avanzato
%
% C) Coerenza con requisiti progetto (0.7 pagine):
% - Real-time: SignalR per notifiche bidirezionali low-latency
% - Scalabilità: architettura stateless con JWT authentication
% - Integrazione MCP: supporto nativo JSON-RPC e stdio transport
% - Configurator3D: SDK SignalR JavaScript per web client
%
% Tabella 3.1: Stack Technology Summary (COMPATTA)
% | Layer          | Tecnologia         | Versione | Motivazione                      |
% |----------------|--------------------|----------|----------------------------------|
% | Runtime        | .NET               | 8 LTS    | Performance + LTS + ecosistema   |
% | Language       | C#                 | 12       | Type-safety + async/await        |
% | Web Framework  | ASP.NET Core       | 8.0      | DI + hosting SignalR             |
% | MCP Integration| MCP .NET SDK       | 0.6.0    | Type-safe tool definition        |
% | Real-Time Comm | SignalR            | 8.0      | Auto-reconnect + fallback        |
% | Authentication | JWT Bearer         | RFC 7519 | Stateless + scalable             |
% | Security       | CORS               | W3C      | Cross-origin frontend            |
% | Transport Sec  | HTTPS/WSS          | TLS 1.3  | End-to-end encryption            |
% | Frontend Lang  | TypeScript         | 5.x      | Type-safety + IntelliSense       |
% | Frontend SDK   | @microsoft/signalr | 8.x      | Browser SignalR client           |
%
% Elementi visivi:
% - Tabella 3.1: Stack summary (10 righe, 4 colonne)
%
% Pagine stimate: 2

%----------------------------------------------------------------------------------------
\section{Piattaforma Backend .NET}
\label{sec:backend-net}
%----------------------------------------------------------------------------------------

% FOCUS: Panoramica essenziale .NET 8, C# 12, ASP.NET Core, MCP SDK
% Approccio: COMPATTO, spiegare COSA/PERCHÉ, NO dettagli implementativi

%----------------------------------------------------------------------------------------
\subsection{.NET 8 e C\# 12: Piattaforma e Linguaggio}
\label{subsec:dotnet-csharp}
%----------------------------------------------------------------------------------------

% Contenuti da sviluppare (1.5 pagine):
%
% A) .NET 8: Piattaforma (0.5 pagine):
% - Piattaforma unified open-source cross-platform (Windows/Linux/macOS)
% - Evoluzione: .NET Framework (Windows-only) → .NET Core → .NET 5+ unified
% - .NET 8 LTS (novembre 2023): supporto 3 anni (fino novembre 2026)
% - Componenti essenziali:
%   * CoreCLR: runtime con JIT compilation e Garbage Collector
%   * Librerie base: System.*, Collections, IO, Networking
%   * ASP.NET Core: framework web per API e SignalR
%   * NuGet: package manager
%
% B) C# 12: Linguaggio (0.4 pagine):
% - Linguaggio object-oriented type-safe, rilasciato con .NET 8
% - Paradigmi: OOP, functional (LINQ), async/await nativo
% - Feature rilevanti progetto:
%   * **Async/await**: gestione I/O asincrono (HTTP, SignalR non-blocking)
%   * **LINQ**: query in-memory eleganti
%   * **Pattern matching**: switch expressions per routing
%   * **Nullable reference types**: null-safety compile-time
%   * **Records**: DTOs immutabili per request/response
%
% C) PERCHÉ .NET 8 + C# 12 (0.6 pagine):
%
% Tabella 3.2: .NET vs Alternative Backend
% | Aspetto     | .NET 8   | Python   | Node.js | Java    |
% |-------------|----------|----------|---------|---------|
% | Performance | ★★★★★    | ★★☆☆☆    | ★★★☆☆   | ★★★★☆   |
% | Async Model | async/await | asyncio | async  | CompletableFuture |
% | Type Safety | Compiled | Optional | No      | Compiled|
% | MCP SDK     | ✅ Ufficiale| ✅    | ✅      | ❌      |
%
% Motivazioni scelta:
% - **Performance**: throughput elevato per real-time
% - **Async/await ergonomico**: sintassi pulita vs callback hell
% - **Type-safety**: compile-time errors
% - **MCP SDK availability**: package NuGet ufficiale
% - **Cross-platform**: deploy Docker Linux
%
% Elementi visivi:
% - Tabella 3.2: Comparison matrix (4×4)
%
% Pagine stimate: 1.5

%----------------------------------------------------------------------------------------
\subsection{ASP.NET Core: Infrastructure Framework}
\label{subsec:aspnet-core}
%----------------------------------------------------------------------------------------

% Contenuti da sviluppare (1 pagina):
%
% A) COSA è ASP.NET Core (0.4 pagine):
% - Framework web moderno cross-platform per .NET
% - Componenti: Kestrel web server, middleware pipeline, DI container, configuration, logging
%
% B) PERCHÉ ASP.NET Core (0.3 pagine):
% - **Performance**: Kestrel high-throughput (benchmark TechEmpower top 10)
% - **DI nativo**: IoC container built-in
% - **Middleware pipeline**: estensibilità
%
% C) Ruolo nel progetto (0.3 pagine):
% - NON usato per hosting HTTP REST API (MarkunoAPI è esterno)
% - Utilizzo SOLO per infrastruttura:
%   * Dependency Injection: registrazione servizi
%   * Configuration: caricamento appsettings.json
%   * Logging: ILogger structured logging
%   * SignalR hosting: Kestrel espone IwineHub
%
% Pagine stimate: 1

%----------------------------------------------------------------------------------------
\subsection{MCP SDK: Astrazione Tool Definition}
\label{subsec:mcp-sdk}
%----------------------------------------------------------------------------------------

% Contenuti da sviluppare (1 pagina - RIDOTTA da 2.5):
%
% A) COSA è MCP SDK (0.4 pagine):
% - Package NuGet: ModelContextProtocol (versione 0.6.0)
% - Framework per implementazione server MCP in .NET
% - Componenti: McpServer base class, [McpTool] attributes, JSON-RPC handler, stdio transport
%
% B) PERCHÉ MCP SDK (0.6 pagine):
%
% Confronto: Manuale vs SDK
%
% **Implementazione manuale JSON-RPC**:
% - Parsing, validazione, routing, serializzazione, error handling manuale
% - Stima: ~500 linee codice boilerplate per 10 tool
%
% **Con MCP SDK**:
% - Tutto automatico: parsing, validazione, routing, serializzazione, errors
% - Stima: ~10 linee per tool (solo business logic)
%
% Vantaggi SDK:
% - **Boilerplate reduction**: ~95% meno codice
% - **Type-safety**: parametri validati compile-time
% - **Developer experience**: IntelliSense, debugging
%
% Elementi visivi:
% - Diagramma 3.3: MCP SDK workflow (AI → JSON-RPC → SDK → method)
%
% Pagine stimate: 1

%----------------------------------------------------------------------------------------
\section{Architettura della Comunicazione}
\label{sec:comunicazione}
%----------------------------------------------------------------------------------------

% FOCUS: Protocolli comunicazione client-server
% Approccio: COMPATTO per protocolli base, DETTAGLIATO per SignalR

%----------------------------------------------------------------------------------------
\subsection{Protocolli di Base: REST, JSON-RPC, WebSocket}
\label{subsec:protocolli-base}
%----------------------------------------------------------------------------------------

% Contenuti da sviluppare (1.5 pagine - UNISCE 3 protocolli):
%
% A) REST API (0.5 pagine):
% - COSA: Architectural style HTTP-based, stateless, resource-based
% - Principi: HTTP verbs (GET/POST/PUT/DELETE), URI risorse, JSON representations
% - PERCHÉ: standard universale, caching, idempotenza
% - Ruolo progetto: MarkunoAPI endpoints (POST /muconf/plist, /pcreate, /radd)
% - Limitazione: request-response only, no server push → serve SignalR
%
% B) JSON-RPC 2.0 (0.5 pagine):
% - COSA: Protocollo RPC lightweight, spec 2.0 del 2010
% - Struttura: { jsonrpc, method, params, id } / { jsonrpc, result, id }
% - PERCHÉ: semplicità (spec 10 pag vs SOAP 1000+), bidirezionale, stateless
% - Ruolo progetto: MCP Protocol usa JSON-RPC per AI ↔ MCP Server
%   * Methods: initialize, tools/list, tools/call
%   * MCP SDK gestisce parsing/serializzazione automaticamente
%
% C) WebSocket Protocol (0.5 pagine):
% - COSA: RFC 6455, protocollo full-duplex su TCP, handshake HTTP upgrade
% - Caratteristiche: bidirezionale, persistent, low-overhead (2-14 byte header), low-latency (<10ms)
% - PERCHÉ: vs HTTP polling (latency 1-5sec, overhead alto, server load)
%
% Tabella 3.3: Polling vs WebSocket (COMPATTA)
% | Aspetto     | Short Polling | WebSocket  |
% |-------------|---------------|------------|
% | Latency     | 1-5 sec       | <10 ms     |
% | Overhead    | Alto          | Minimo     |
% | Server Load | Alto          | Basso      |
% | Scalabilità | Bassa         | Alta       |
%
% - Limitazioni WebSocket: no fallback automatico, riconnessione manuale, no typed messages
% - → SignalR risolve queste limitazioni (vedi 3.3.2)
%
% Elementi visivi:
% - Tabella 3.3: Polling vs WebSocket (4×2)
%
% Pagine stimate: 1.5

%----------------------------------------------------------------------------------------
\subsection{SignalR: Framework Real-Time}
\label{subsec:signalr-framework}
%----------------------------------------------------------------------------------------

% Contenuti da sviluppare (3 pagine - RIDOTTA da 4.5):
%
% A) COSA è SignalR (0.8 pagine):
% - Libreria ASP.NET Core per comunicazione real-time client-server
% - Astrazione high-level su WebSocket con fallback automatico
% - Componenti principali:
%   * **Transport layer**: WebSocket (preferito) → Server-Sent Events → Long Polling (fallback)
%   * **Hub pattern**: Clients.All.Method() (broadcast), Clients.Client(id).Method() (unicast)
%   * **Strongly-typed hubs**: interfaccia IClient, compile-time safety
%   * **Auto-reconnection**: retry con backoff [0, 2, 5, 10] secondi
%   * **Lifecycle events**: OnConnectedAsync, OnDisconnectedAsync
%
% B) PERCHÉ SignalR (0.8 pagine):
%
% Tabella 3.4: WebSocket vs SignalR (COMPATTA)
% | Aspetto         | WebSocket Raw       | SignalR                 |
% |-----------------|---------------------|-------------------------|
% | Fallback        | Manuale             | Automatico (SSE → LP)   |
% | Riconnessione   | Custom              | Automatica backoff      |
% | Typed messages  | Serializzazione man | Strongly-typed methods  |
% | Broadcasting    | Loop manuale        | Clients.All.Method()    |
% | Complessità     | 300-500 lines       | 20-30 lines             |
%
% Vantaggi SignalR:
% - **Produttività**: 90% meno codice boilerplate
% - **Affidabilità**: auto-reconnect, fallback transport
% - **Developer experience**: type-safety, IntelliSense
%
% C) Ruolo nel progetto (1 pagina):
%
% **IwineHub**: SignalR Hub esterno pre-esistente
% - Bridging MCP Server ↔ Configurator3D
% - Funzionalità: routing messaggi (SendMessage), broadcasting, ConnectionId exchange
% - Hosting: Kestrel porta 7193, JWT authentication, CORS configurato
%
% **SignalR Client .NET**: usato da MCP Server
% - Package: Microsoft.AspNetCore.SignalR.Client
% - API: StartAsync(), On<T>(event, handler), InvokeAsync(method, args)
% - Auto-reconnect: [0, 2, 5, 10] secondi backoff
%
% **SignalR Client Browser**: usato da Configurator3D
% - Package npm: @microsoft/signalr v8.x
% - Handlers: on("open", ...), on("create", ...) per comandi MCP
% - ACK pattern: invoke("SendAck", commandId) conferma elaborazione
%
% **Dual-Channel Pattern**: REST + SignalR complementari
% - REST: operazioni CRUD pesanti
% - SignalR: notifiche real-time leggere
% - Vantaggi: separation of concerns, resilienza
%
% D) Caratteristiche determinanti (0.4 pagine):
% - **Bidirezionalità real-time**: latency <10ms vs polling 1-5 sec
% - **Affidabilità**: auto-reconnect per sessioni lunghe
% - **Fallback transport**: 100% compatibility in ambienti restrittivi
% - **Ecosystem maturity**: Microsoft production-ready, LTS support
%
% Elementi visivi:
% - Tabella 3.4: WebSocket vs SignalR (5×3)
% - Diagramma 3.4: Dual-Channel pattern (MCP → REST + SignalR → Configurator)
%
% Pagine stimate: 3

%----------------------------------------------------------------------------------------
\section{Sicurezza Applicativa}
\label{sec:sicurezza}
%----------------------------------------------------------------------------------------

% FOCUS: JWT autenticazione stateless, CORS, HTTPS
% Approccio: DETTAGLIATO per JWT, COMPATTO per CORS/HTTPS

%----------------------------------------------------------------------------------------
\subsection{JWT: Autenticazione Stateless}
\label{subsec:jwt}
%----------------------------------------------------------------------------------------

% Contenuti da sviluppare (1.5 pagine - RIDOTTA da 3):
%
% A) COSA è JWT (0.6 pagine):
% - RFC 7519: JSON Web Token per access token stateless
% - Struttura: header.payload.signature (3 parti Base64Url encoded)
%   * Header: { "alg": "HS256", "typ": "JWT" }
%   * Payload: { "sub": "user123", "exp": 1735689600, "name": "..." } (claims)
%   * Signature: HMACSHA256(header + payload, secret_key)
% - Verifica: server ricalcola signature, check exp claim
%
% B) PERCHÉ JWT (0.6 pagine):
%
% Tabella 3.5: Session vs JWT (COMPATTA)
% | Aspetto      | Session-based     | JWT                |
% |--------------|-------------------|--------------------|
% | State        | Stateful          | Stateless          |
% | Storage      | Server memory/DB  | Client-side        |
% | Scalability  | Sticky sessions   | Horizontal scaling |
% | CSRF         | Vulnerable        | Immune             |
% | Cross-domain | Problematic       | Easy               |
%
% Vantaggi JWT:
% - **Stateless**: scalabilità orizzontale illimitata
% - **Self-contained**: no database lookup per ogni request
% - **Cross-domain**: CORS-friendly, no cookie restrictions
%
% C) Ruolo progetto (0.3 pagine):
% - MarkunoAPI emette JWT al login: POST /api/login → { Token }
% - MCP Server invia JWT in Authorization header: "Bearer <token>"
% - MarkunoAPI valida signature e exp claims
%
% Security considerations (breve):
% - HTTPS enforcement, secret protection, short expiration (15-30 min)
%
% Elementi visivi:
% - Tabella 3.5: Session vs JWT (5×3)
% - Diagramma 3.5: JWT flow (Login → Token → Request → Validate)
%
% Pagine stimate: 1.5

%----------------------------------------------------------------------------------------
\subsection{CORS e Transport Security}
\label{subsec:cors-https}
%----------------------------------------------------------------------------------------

% Contenuti da sviluppare (1 pagina - UNISCE CORS + HTTPS):
%
% A) CORS: Cross-Origin Resource Sharing (0.6 pagine):
% - Problema: Same-Origin Policy browser blocca requests cross-domain
% - Scenario progetto:
%   * Configurator3D: https://configurator.markuno.com
%   * SignalR Hub: https://api.markuno.com:7193 (porta diversa)
%   * Browser blocca WebSocket → serve CORS
% - Soluzione: server invia header Access-Control-*
%   * Access-Control-Allow-Origin: origin autorizzato
%   * Access-Control-Allow-Credentials: true (REQUIRED per SignalR + auth)
% - Preflight request: browser OPTIONS prima request effettiva
% - Ruolo progetto: IwineHub configurato CORS per Configurator3D origin
%
% B) HTTPS/WSS: Transport Layer Security (0.4 pagine):
% - HTTPS: HTTP over TLS, WSS: WebSocket Secure over TLS
% - TLS 1.3: encryption end-to-end, AES-256-GCM
% - PERCHÉ: confidenzialità (JWT encrypted), integrità, autenticità
% - Ruolo progetto:
%   * HTTPS: tutte chiamate REST MarkunoAPI
%   * WSS: SignalR WebSocket
%   * Sviluppo: self-signed certificate, Produzione: Let's Encrypt
% - Senza TLS: JWT intercettabile (MITM attack)
%
% Elementi visivi:
% - Diagramma 3.6: CORS preflight flow (OPTIONS → headers → request)
%
% Pagine stimate: 1

%----------------------------------------------------------------------------------------
\section{Integrazione Frontend}
\label{sec:frontend}
%----------------------------------------------------------------------------------------

% FOCUS: TypeScript e SignalR client browser
% Approccio: COMPATTO, essenziale

%----------------------------------------------------------------------------------------
\subsection{TypeScript: Type-Safety JavaScript}
\label{subsec:typescript}
%----------------------------------------------------------------------------------------

% Contenuti da sviluppare (0.7 pagine):
%
% A) COSA è TypeScript (0.3 pagine):
% - Superset JavaScript con type system statico
% - Microsoft, open-source, versione 5.x (2023)
% - Compilation: TypeScript → transpiler tsc → JavaScript (ES6)
%
% B) PERCHÉ TypeScript (0.4 pagine):
%
% Tabella 3.6: JavaScript vs TypeScript (COMPATTA)
% | Aspetto      | JavaScript  | TypeScript         |
% |--------------|-------------|--------------------|
% | Type check   | Runtime     | Compile-time       |
% | Errors       | Production  | Development        |
% | IntelliSense | Limited     | Full autocomplete  |
% | Refactoring  | Risky       | Safe (type-checked)|
%
% Vantaggi progetto:
% - **Compile-time errors**: catch typo method names BEFORE runtime
% - **IntelliSense**: autocomplete SignalR methods
% - **Type safety**: message structure garantita
%
% Ruolo progetto:
% - Configurator3D scritto in TypeScript 5.x
% - SignalR client: import @microsoft/signalr, type-safe API
%
% Pagine stimate: 0.7

%----------------------------------------------------------------------------------------
\subsection{SignalR Client Browser}
\label{subsec:signalr-browser}
%----------------------------------------------------------------------------------------

% Contenuti da sviluppare (0.8 pagine):
%
% A) COSA è @microsoft/signalr (0.3 pagine):
% - Package npm: client SignalR per browser JavaScript/TypeScript
% - Versione 8.x (aligned con SignalR server 8.0)
% - API: HubConnectionBuilder, on(), invoke(), start()
%
% B) Configurazione (0.3 pagine):
% - HubConnectionBuilder: withUrl(), withAutomaticReconnect([0, 2, 5, 10]), configureLogging()
% - Event handlers: on("GetMessage", handler), on("GetConnectionId", handler)
% - Server invocation: invoke("SendMessage", receiverId, message)
% - Lifecycle: start(), stop(), onclose(callback)
%
% C) Ruolo progetto (0.2 pagine):
% - Handlers comandi MCP: on("open", ...), on("create", ...), on("list", ...), on("add", ...)
% - ACK pattern: invoke("SendAck", commandId, "success")
% - UI feedback: connection status indicator (verde/giallo/rosso)
% - Gestione errori: auto-reconnect, fallback Long Polling
%
% Elementi visivi:
% - Listing 3.6: Esempio HubConnectionBuilder setup (pseudo-code)
%
% Pagine stimate: 0.8

%----------------------------------------------------------------------------------------
% FINE CAPITOLO 3: Stack Tecnologico
% Pagine totali stimate: 2 + 3.5 + 4.5 + 2.5 + 1.5 = ~14 pagine
%----------------------------------------------------------------------------------------
\chapter{Progettazione del Sistema}
\label{chap:progettazione}
%----------------------------------------------------------------------------------------

%----------------------------------------------------------------------------------------
\section{Architettura Generale del Sistema}
\label{sec:architettura-generale}
%----------------------------------------------------------------------------------------

% Panoramica dell'architettura a tre livelli:
% - Livello MCP Server: MarkunoApiTools espone tool MCP per l'AI Assistant
% - Livello Bridge: SignalRService gestisce comunicazione real-time
% - Livello External Systems: MarkunoAPI (REST) e Configurator3D (client)
%
% Concetti chiave da evidenziare:
% - Pattern Architetturale: Layered Architecture con separazione responsabilità
% - Protocolli di comunicazione: HTTP/REST sincrono + SignalR asincrono
% - Dependency Injection: configurazione centralizzata nel Program.cs
% - Motivazioni: Isolamento tra componenti, testabilità, manutenibilità
%
% Diagramma: diagram_1_overview.mmd
% Pagine stimate: 2-3

%----------------------------------------------------------------------------------------
\section{Sistema di Configurazione e Bootstrap}
\label{sec:configurazione-bootstrap}
%----------------------------------------------------------------------------------------

% Gestione della configurazione applicativa:
% - AppSettings: struttura con BaseUrl, MarkunoCredentials, SignalRConfig
% - Pattern Dependency Injection: registrazione servizi singleton
% - IConfiguration: caricamento da appsettings.json
% - Responsabilità Program.cs: load config → register services → configure MCP
%
% Concetti chiave:
% - Externalizzazione configurazione: zero hardcoding
% - Environment-specific settings: appsettings.Development.json, appsettings.Production.json
% - Singleton pattern: SignalRService condiviso tra tool
% - Security: credenziali in file esclusi da version control
%
% Diagramma: diagram_2_configuration.mmd
% Pagine stimate: 2-3

%----------------------------------------------------------------------------------------
\section{Servizio di Comunicazione Real-Time}
\label{sec:servizio-signalr}
%----------------------------------------------------------------------------------------

% Architettura del SignalRService:
% - Campi privati: _hubConnection, _logger, _isConnected, _receiveHandlers
% - Metodi pubblici: ConnectAsync, SendCommandAsync, CallHubMethodAsync, OnReceiveMessage
% - HubConnection lifecycle: build → start → reconnect → dispose
%
% Funzionalità avanzate:
% - Auto-reconnessione: tentativi multipli con intervalli crescenti (0s, 2s, 5s, 10s)
% - Multiple endpoint fallback: prova URL base, URL+/hub, URL+/configuratorHub
% - Event handling: registrazione handler per messaggi in arrivo
% - Self-signed certificate support: per ambiente di sviluppo
%
% Concetti chiave:
% - Observer Pattern: registrazione callback per ReceiveMessage
% - Resilienza: retry logic automatico
% - Logging: tracciamento stati connessione
% - Threading safety: gestione concorrente handler
%
% Diagramma: diagram_3_signalr_service.mmd
% Pagine stimate: 3-4

%----------------------------------------------------------------------------------------
\section{Infrastruttura SignalR e WebSocket}
\label{sec:infrastruttura-signalr}
%----------------------------------------------------------------------------------------

% Questa sezione descrive in dettaglio l'architettura del bridge SignalR esistente
% utilizzato come layer di comunicazione real-time tra MCP Server e Configurator 3D.
% Il bridge implementa il pattern Hub di SignalR e gestisce tutti gli aspetti della
% comunicazione WebSocket, inclusi routing, broadcasting e comunicazione point-to-point.

%----------------------------------------------------------------------------------------
\subsection{Architettura Multi-Layer del Bridge}
\label{subsec:architettura-bridge}
%----------------------------------------------------------------------------------------

% Architettura a livelli del sistema SignalR:
%
% CLIENT LAYER:
% - Web Application (TypeScript/JavaScript)
% - Mobile Application (Native/Hybrid)
% - Desktop Application (.NET/Electron)
% - Configurator3D (client grafico specifico del progetto)
%
% TRANSPORT LAYER:
% - WebSocket Protocol (preferito): comunicazione bidirezionale full-duplex
% - Server-Sent Events (fallback): per browser senza supporto WebSocket
% - Long Polling (fallback finale): massima compatibilità
% - Fallback automatico gestito da SignalR Client SDK
%
% SIGNALR CORE LAYER:
% - SignalR Client SDK (@microsoft/signalr)
% - Connection Manager: gestione ciclo di vita connessioni
% - Protocol Handler: serializzazione/deserializzazione (JSON/MessagePack)
%
% APPLICATION LAYER (IwineHub):
% - CORS Middleware: gestione Cross-Origin Resource Sharing
% - Authentication: validazione JWT token
% - IwineHub: hub principale per routing messaggi
% - IClient Interface: contratto strongly-typed per comunicazione server-to-client
%
% BUSINESS LAYER:
% - Message Handler: gestione ciclo di vita messaggi
% - Routing Engine: instradamento basato su Action/Route
% - Validation Service: validazione struttura e contenuto messaggi
%
% INFRASTRUCTURE LAYER:
% - Configuration: gestione appsettings.json
% - Service Extensions: extension methods per configurazione servizi
% - Logging: sistema logging centralizzato (ILogger)
%
% DATA LAYER:
% - Message DTO: Data Transfer Object per messaggi
% - Hub Context: contesto runtime con informazioni connessioni
%
% Concetti chiave:
% - Separation of Concerns: ogni layer ha responsabilità specifiche
% - Transport Agnostic: fallback automatico tra protocolli
% - Strongly-Typed Hub: type-safety per comunicazione server-to-client
% - Dependency Injection: configurazione servizi via extension methods
%
% Diagramma: 05-component-diagram.md (diagramsSignalR)
% Pagine stimate: 2-3

%----------------------------------------------------------------------------------------
\subsection{Modello delle Classi e Pattern Hub}
\label{subsec:modello-classi-hub}
%----------------------------------------------------------------------------------------

% Struttura delle classi principali del sistema SignalR:
%
% IwineHub (extends Hub<IClient>):
% - Componente centrale che gestisce tutte le comunicazioni SignalR
% - Metodi principali:
%   - SendMessage(Message message): broadcasting o routing messaggi
%   - SendConnectionId(string receiverId, string senderId): scambio ConnectionId
% - Proprietà ereditate da Hub<T>:
%   - Clients: IHubCallerClients<IClient> per invocare metodi su client
%   - Context: HubCallerContext con info connessione corrente
%   - Groups: IGroupManager per gestione gruppi client
% - Eventi lifecycle:
%   - OnConnectedAsync(): invocato alla connessione client
%   - OnDisconnectedAsync(Exception): invocato alla disconnessione
%
% IClient (interface):
% - Definisce contratto per metodi invocabili sui client (Strongly-Typed Hub)
% - Metodi:
%   - GetMessage(Message message): riceve messaggi broadcast o diretti
%   - GetConnectionId(string connectionId): riceve ConnectionId di altro client
%
% Message (DTO):
% - Data Transfer Object per trasferimento messaggi tra client
% - Proprietà:
%   - Action (string): tipo di azione da eseguire (open, create, list_elements, etc.)
%   - Name (string): nome messaggio/evento
%   - Route (string): percorso destinazione per routing
%   - Params (object): parametri dinamici associati (receiverId, payload, etc.)
%
% Program (static):
% - Configurazione e bootstrap applicazione ASP.NET Core
% - Responsabilità:
%   - ConfigureServices(): registrazione servizi (AddSignalR, AddCors, AddAuth)
%   - ConfigureMiddleware(): pipeline middleware (UseCors, UseAuth, MapHub)
%
% IServiceCollectionExtensions (static):
% - Extension methods per configurazione modulare
% - Metodi:
%   - AddCustomAuthentication(): configura JWT Bearer authentication
%   - AddCustomAuthorization(): configura policy autorizzazione
%
% Concetti chiave:
% - Hub Pattern: centralizzazione routing messaggi real-time
% - Strongly-Typed Hub: type-safety tramite interfaccia IClient
% - DTO Pattern: Message come contratto dati tra client/server
% - Extension Methods: configurazione modulare e riutilizzabile
% - Lifecycle Hooks: OnConnectedAsync/OnDisconnectedAsync per gestione eventi
%
% Diagramma: 01-class-diagram.md (diagramsSignalR)
% Pagine stimate: 2-3

%----------------------------------------------------------------------------------------
\subsection{Gestione del Ciclo di Vita delle Connessioni}
\label{subsec:lifecycle-connessioni}
%----------------------------------------------------------------------------------------

% Fasi della connessione client-server SignalR:
%
% FASE 1 - NEGOZIAZIONE (HTTP Negotiate):
% - Client SignalR SDK invia HTTP POST a /hub/negotiate
% - Server risponde con:
%   - Connection Token: identificatore univoco negoziazione
%   - Available Transports: lista trasporti supportati [WebSocket, SSE, LongPolling]
%   - Negotiation Version: versione protocollo SignalR
%
% FASE 2 - UPGRADE WEBSOCKET:
% - Se WebSocket supportato, client richiede HTTP Upgrade
% - Header: Connection: Upgrade, Upgrade: websocket
% - Handshake WebSocket (RFC 6455)
% - Server accetta: StatusCode 101 Switching Protocols
% - Connessione TCP persistente stabilita
%
% FASE 3 - REGISTRAZIONE HUB:
% - Server invoca IwineHub.OnConnectedAsync()
% - Hub ottiene ConnectionId dal Context (GUID univoco)
% - Hub invia ConnectionId al client via IClient.GetConnectionId()
% - Client salva ConnectionId per comunicazioni future
%
% FASE 4 - FASE OPERATIVA:
% - Client e server possono scambiare messaggi bidirezionalmente
% - Client invoca metodi hub: SendMessage(message)
% - Server invoca metodi client: Clients.Client(id).GetMessage(message)
% - Keep-alive automatico gestito da SignalR (ping/pong)
%
% FASE 5 - DISCONNESSIONE:
% - Disconnessione può essere:
%   - Esplicita: client chiama connection.stop()
%   - Implicita: timeout, network error, server shutdown
% - Server invoca IwineHub.OnDisconnectedAsync(Exception)
% - Hub rilascia risorse (rimuove da gruppi, cleanup stato)
% - ConnectionId viene invalidato
%
% Stati della connessione (State Machine):
% - Disconnected: stato iniziale, nessuna connessione
% - Connecting: tentativo connessione in corso (timeout 30s)
% - Connected: connessione stabilita, ConnectionId ricevuto
% - Active: stato operativo con sotto-stati:
%   - Idle: pronto per send/receive
%   - Sending: invio messaggio in corso
%   - WaitingACK: attesa conferma server
%   - Receiving: ricezione messaggio in corso
%   - Processing: elaborazione messaggio
%   - Error: errore temporaneo con retry
% - Reconnecting: tentativo riconnessione automatica (max 5 tentativi, backoff esponenziale)
% - Disconnecting: disconnessione in corso
%
% Concetti chiave:
% - Handshake HTTP: negoziazione protocollo e trasporto
% - WebSocket Upgrade: transizione da HTTP a WS
% - ConnectionId: identificatore univoco per routing P2P
% - State Machine: gestione robusta stati connessione
% - Keep-Alive: mantenimento connessione con ping/pong automatici
% - Graceful Shutdown: cleanup risorse in disconnessione
%
% Diagrammi: 
% - 02-sequence-connection.md (sequence diagram connessione)
% - 07-state-diagram.md (state machine connessione)
% Pagine stimate: 3-4

%----------------------------------------------------------------------------------------
\subsection{Pattern di Comunicazione: Broadcasting e Point-to-Point}
\label{subsec:pattern-comunicazione}
%----------------------------------------------------------------------------------------

% BROADCASTING (Many-to-Many):
%
% Meccanismo:
% - Client mittente invoca SendMessage(message) con Route="/broadcast"
% - Hub valida messaggio (Action valido, Route presente, Params validi)
% - Hub invoca Clients.All.GetMessage(message)
% - SignalR invia messaggio in parallelo a tutti i client connessi
% - Ogni client elabora messaggio indipendentemente
%
% Caratteristiche:
% - Fire-and-forget: mittente non attende conferma riceventi
% - Invio parallelo: tutti i client ricevono simultaneamente
% - Indipendenza: elaborazione autonoma per ogni client
% - No acknowledgment: nessuna garanzia di ricezione/elaborazione
%
% Casi d'uso:
% - Notifiche di sistema (manutenzione, aggiornamenti)
% - Eventi globali (nuovo ordine, cambio stato applicazione)
% - Sincronizzazione dati (cache invalidation)
% - Broadcasting eventi pubblici
%
%
% POINT-TO-POINT (One-to-One):
%
% Meccanismo:
% FASE 1 - Scambio ConnectionId:
% - Client A richiede ConnectionId di Client B
% - Client A invoca SendConnectionId(receiverId: "B", senderId: "A")
% - Hub verifica esistenza Client B nel Context
% - Hub invoca Clients.Client("B").GetConnectionId("A")
% - Client B riceve e salva ConnectionId di A per future comunicazioni
%
% FASE 2 - Invio messaggio diretto:
% - Client A invoca SendMessage(message) con Params.receiverId = "B"
% - Hub estrae receiverId dai Params
% - Hub ottiene proxy Client B dal Context: GetClient(receiverId)
% - Se Client B connesso:
%   - Hub invoca Clients.Client("B").GetMessage(message)
%   - Client B elabora messaggio
%   - Hub risponde a Client A: Delivered (200)
% - Se Client B disconnesso:
%   - Hub risponde a Client A: Client offline (404)
%   - Possibili strategie:
%     - Message Queue: salva in coda per delivery posticipato
%     - Push Notification: notifica via email/push
%     - Retry Logic: tentativo automatico reinvio
%
% Caratteristiche:
% - Bassa latenza: comunicazione diretta senza intermediari
% - Real-time delivery: se entrambi i client online
% - Routing efficiente: server gestisce solo instradamento
% - Acknowledgment opzionale: conferma ricezione se richiesto
%
% Casi d'uso:
% - Chat privata tra utenti
% - Notifiche personali
% - Comandi diretti (MCP → Configurator3D)
% - Sincronizzazione stato tra client specifici
%
% Concetti chiave:
% - Clients.All: broadcasting a tutti i client
% - Clients.Client(connectionId): targeting client specifico
% - Clients.Group(groupName): broadcasting a gruppo
% - ConnectionId Exchange: prerequisito per comunicazione P2P
% - Offline Handling: gestione client disconnessi
% - Parallel Processing: elaborazione concorrente messaggi
%
% Diagrammi:
% - 03-sequence-broadcast.md (sequence diagram broadcasting)
% - 04-sequence-p2p.md (sequence diagram point-to-point)
% Pagine stimate: 3-4

%----------------------------------------------------------------------------------------
\subsection{Flusso di Elaborazione Messaggi}
\label{subsec:flusso-elaborazione}
%----------------------------------------------------------------------------------------

% Pipeline completa di elaborazione messaggi dal client al server:
%
% FASE 1 - CLIENT-SIDE: PREPARAZIONE E INVIO
%
% Serializzazione:
% - Client costruisce oggetto Message {Action, Name, Route, Params}
% - SignalR Client SDK serializza automaticamente in JSON
% - Esempio: {Action: "notifica", Name: "nuovo_ordine", Route: "/orders/broadcast", 
%             Params: {orderId: 123, status: "pending"}}
%
% Selezione Trasporto:
% - SignalR sceglie automaticamente miglior trasporto disponibile
% - Ordine preferenza:
%   1. WebSocket (preferito): full-duplex, bassa latenza
%   2. Server-Sent Events: fallback per browser senza WebSocket
%   3. Long Polling: fallback finale per massima compatibilità
% - Trasporto trasparente per sviluppatore
%
%
% FASE 2 - SERVER-SIDE: RICEZIONE E VALIDAZIONE
%
% Deserializzazione:
% - Server riceve payload JSON via trasporto
% - SignalR deserializza automaticamente in oggetto Message
% - Binding automatico delle proprietà (Action, Name, Route, Params)
%
% Validazione:
% - Controlli eseguiti:
%   - Message non null
%   - Action è stringa valida e non vuota
%   - Route presente e ben formata (pattern regex)
%   - Params è oggetto valido (può essere null)
% - Se validazione fallisce:
%   - throw HubException("Invalid message format")
%   - Client riceve errore e può gestirlo
%
%
% FASE 3 - ROUTING DEL MESSAGGIO
%
% Analisi Route:
% - Route Pattern Matching:
%   - /broadcast → Clients.All.GetMessage(message)
%   - /direct/:connectionId → Clients.Client(connectionId).GetMessage(message)
%   - /group/:groupName → Clients.Group(groupName).GetMessage(message)
%
% Estrazione parametri:
% - Da Route: parsing parametri dinamici (es. :connectionId)
% - Da Params: lettura proprietà (es. Params.receiverId)
%
% Verifica destinatari:
% - Per route /direct: verifica esistenza connectionId nel Context
% - Per route /group: verifica esistenza gruppo
% - Se destinatario non trovato: gestione errore (404 o queue)
%
%
% FASE 4 - INVIO E DELIVERY
%
% Invio parallelo (broadcast/group):
% - SignalR utilizza Task.WhenAll per invio concorrente
% - Nessun blocco se un client è lento
% - Fire-and-forget: no attesa conferme
%
% Invio singolo (direct):
% - Invio a client specifico
% - Possibile attesa acknowledgment se implementato
%
%
% FASE 5 - CLIENT-SIDE: RICEZIONE ED ELABORAZIONE
%
% Ricezione evento:
% - Client riceve evento GetMessage tramite handler registrato
% - connection.on("GetMessage", (message) => {...})
%
% Deserializzazione client:
% - SignalR deserializza JSON in oggetto Message
%
% Elaborazione per Action:
% - Switch/dispatch basato su message.Action:
%   - "notifica" → Aggiorna UI, mostra notifica
%   - "message" → Visualizza messaggio in chat
%   - "update" → Aggiorna dati in cache/store
%   - "command" → Esegui comando applicazione (es. open, create)
%
% Acknowledgment (opzionale):
% - Se richiesto, client invia ACK al server
% - await connection.invoke("SendAck", messageId)
%
% Concetti chiave:
% - Serializzazione automatica: trasparente per sviluppatore
% - Transport fallback: robustezza connessione
% - Route-based routing: pattern matching per instradamento
% - Parallel delivery: performance in broadcasting
% - Action-based dispatch: pattern command per elaborazione
% - Optional ACK: conferma ricezione quando necessario
%
% Diagramma: 08-data-flow-diagram.md (flowchart elaborazione completa)
% Pagine stimate: 3-4

%----------------------------------------------------------------------------------------
\subsection{Integrazione con l'Architettura MCP}
\label{subsec:integrazione-mcp-signalr}
%----------------------------------------------------------------------------------------

% Collegamento tra bridge SignalR e architettura MCP complessiva:
%
% RUOLO DEL BRIDGE SIGNALR:
% - Layer intermedio tra MCP Server e Configurator3D client
% - Traduzione comandi MCP in messaggi SignalR
% - Gestione comunicazione bidirezionale real-time
% - Notifiche asincrone da client a MCP
%
% FLUSSO DI INTEGRAZIONE:
%
% 1. AI Assistant → MCP Server:
%    - Prompt testuale: "Apri il progetto Cucina Milano"
%    - MCP traduce in tool call: OpenProject(projectName: "Cucina Milano")
%
% 2. MCP Server → SignalRService:
%    - Tool invoca SignalRService.SendMessage()
%    - Costruisce Message: {Action: "open", Name: projectId, Route: "/direct/:connectionId"}
%    - SignalRService invoca IwineHub tramite HubConnection
%
% 3. IwineHub → Configurator3D:
%    - Hub instrada messaggio: Clients.Client(receiverId).GetMessage(message)
%    - Client riceve comando via WebSocket
%    - Client elabora: carica progetto, aggiorna vista 3D
%
% 4. Configurator3D → MCP Server (response):
%    - Client invia risposta: connection.invoke("SendMessage", responseMessage)
%    - IwineHub riceve e instrada a MCP connectionId
%    - SignalRService riceve via handler OnReceiveMessage
%    - MCP tool completa e risponde ad AI Assistant
%
% VANTAGGI DELL'INTEGRAZIONE:
% - Disaccoppiamento: MCP non dipende da dettagli SignalR
% - Real-time: aggiornamenti istantanei senza polling
% - Bidirezionalità: comunicazione full-duplex
% - Scalabilità: SignalR gestisce multiple connessioni
% - Resilienza: riconnessione automatica gestita da SignalRService
%
% CONSIDERAZIONI DI DESIGN:
% - SignalRService come singleton: condiviso tra tutti i tool MCP
% - Message DTO unificato: contratto comune MCP/SignalR/Client
% - ConnectionId mapping: gestione identificatori tra layer
% - Error handling: propagazione errori tra layer
% - Timeout management: gestione timeout operazioni asincrone
%
% Concetti chiave:
% - Bridge Pattern: SignalR come mediatore tra MCP e Client
% - Layered Architecture: separazione responsabilità tra layer
% - Message-Oriented Middleware: comunicazione basata su messaggi
% - Async/Await: gestione operazioni asincrone end-to-end
% - Singleton Service: istanza condivisa SignalRService
%
% Diagrammi: tutti i diagrammi precedenti mostrano aspetti di questa integrazione
% Pagine stimate: 2-3

%----------------------------------------------------------------------------------------
\section{Sistema di Autenticazione}
\label{sec:autenticazione}
%----------------------------------------------------------------------------------------

% Modello di autenticazione:
% - User model: Id, Name, Email, Level, Token, Ruoli, Nome, Cognome
% - LoginResponse/LoginData DTO: wrapping risposta API
% - Bearer Token: JWT salvato in campo statico _authToken
% - Metodi: Login, Logout, CheckAuthStatus, AutoLoginIfNeeded
%
% Flusso di autenticazione:
% 1. Ricezione credenziali (user-provided o da config)
% 2. POST /api/login → MarkunoAPI
% 3. Estrazione token da LoginResponse
% 4. Salvataggio in variabile statica per richieste future
% 5. Header "Authorization: Bearer {token}" in chiamate successive
%
% Concetti chiave:
% - Stateful authentication: token in memoria per sessione applicativa
% - Auto-login: credenziali default da appsettings.json
% - Authorization levels: campo Level e Ruoli per permessi
% - Security considerations: gestione scadenza token (401 Unauthorized)
%
% Diagramma: diagram_4_authentication.mmd
% Pagine stimate: 2-3

%----------------------------------------------------------------------------------------
\section{Gestione Progetti}
\label{sec:gestione-progetti}
%----------------------------------------------------------------------------------------

% Modello dati progetti:
% - Project model: Id, Des, Status, DtCrea, DtMod, Importo, User, Note, dati cliente
% - ProjectsResponse/ProjectsData DTO: wrapping lista progetti
% - ProjectField: metadati campi (Cod, Des, Type, Visible, Sort)
%
% Operazioni CRUD:
% - GetProjects: recupero lista con filtro onlyMy
% - ProjectExists: verifica esistenza per ID o nome (case-insensitive)
% - CreateProject: creazione via SignalR (invia comando al Configurator3D)
% - OpenProject: apertura via SignalR + ricerca per nome
%
% Concetti chiave:
% - Repository Pattern: astrazione accesso dati tramite MarkunoAPI
% - Dual-channel approach: lettura via REST, write operations via SignalR
% - Search flexibility: ricerca case-insensitive per user experience
% - Owner tracking: associazione User ai progetti
%
% Diagramma: diagram_5_projects.mmd
% Pagine stimate: 3-4

%----------------------------------------------------------------------------------------
\section{Gestione Articoli e Varianti}
\label{sec:gestione-articoli}
%----------------------------------------------------------------------------------------

% Sistema catalogo prodotti:
% - RuleSetItem model: Cod (parametro), Opz (valore), IsDef, IsLock
% - VariantOptions: Id (catalogo), Name (attributi), Options (mappa chiave-valore)
%
% Operazioni:
% - AddArticle: inserimento articolo + applicazione varianti
% - GetArticleInfo: recupero metadati articolo da catalogo
% - GetVariants: recupero opzioni varianti disponibili
% - SearchCatalogItems: ricerca nel catalogo per categoria/modello
%
% Flusso complesso AddArticle (pattern GET-MODIFY-SAVE):
% 1. POST /muconf/radd → inserimento articolo base, riceve rowId
% 2. POST /muconf/rget → recupero stato corrente con campo "pars"
% 3. Modifica locale campo pars applicando ruleset
% 4. POST /muconf/rsave → salvataggio pars modificato
% 5. Notifica client 3D via SignalR
%
% Concetti chiave:
% - Command Pattern: operazioni come AddArticle wrappate in tool MCP
% - GET-MODIFY-SAVE Pattern: lettura → modifica locale → scrittura
% - Configuration system: ruleset per parametrizzazione articoli
% - Catalog abstraction: separazione catalogo prodotti da logica business
%
% Diagramma: diagram_6_articles_variants.mmd
% Pagine stimate: 4-5

%----------------------------------------------------------------------------------------
\section{Protocollo di Messaggistica SignalR}
\label{sec:protocollo-messaggistica}
%----------------------------------------------------------------------------------------

% Struttura messaggi:
% - Message model: Action, Name, Route, Params
% - Azioni supportate: open, create, list_elements, add_article
%
% Comunicazione bidirezionale:
% - Server → Client: SendHubMessage invia comandi al Configurator3D
% - Client → Server: ListElements richiede dati, GetLastListElements recupera risposta
% - Handler registration: EnsureListElementsHandlerRegistered per callback
%
% Concetti chiave:
% - Command Pattern: action come discriminante operazione
% - Request-Response pattern: messaggi con risposta asincrona
% - Event-driven architecture: handler registrati per messaggi specifici
% - Payload caching: _lastListElementsPayload per recupero differito
%
% Diagramma: diagram_7_signalr_messages.mmd
% Pagine stimate: 3-4

%----------------------------------------------------------------------------------------
\section{Flussi di Lavoro Principali}
\label{sec:flussi-lavoro}
%----------------------------------------------------------------------------------------

%----------------------------------------------------------------------------------------
\subsection{Caso d'Uso: Login e Recupero Progetti}
\label{subsec:login-progetti}
%----------------------------------------------------------------------------------------

% Flusso autenticazione:
% - Fase 1: Login (username/password → POST /api/login → salva token)
% - Fase 2: GetProjects (usa token → POST /muconf/plist → lista progetti)
% - AutoLogin: uso credenziali default se omesse
% - Gestione errori: 401 Unauthorized se token scaduto
%
% Concetti chiave:
% - Stateful session: token JWT persistente in memoria
% - Default credentials: facilitazione testing/sviluppo
% - Bearer authentication: standard HTTP per REST API
%
% Diagramma: sequence_1_login_getprojects.mmd
% Pagine stimate: 2

%----------------------------------------------------------------------------------------
\subsection{Caso d'Uso: Creazione e Apertura Progetto}
\label{subsec:creazione-apertura-progetto}
%----------------------------------------------------------------------------------------

% Flusso creazione progetto:
% - CreateProject: costruisce Message {action: "create", params: {des, note, open}}
% - Invio via SignalR → Configurator3D mostra dialog pre-compilato
% - Client conferma → POST /muconf/pcreate lato client
% - Opzionale: apertura automatica se open=true
%
% Flusso apertura progetto:
% - OpenProject: ricerca progetto per nome (case-insensitive)
% - Costruisce Message {action: "open", name: projectId}
% - Invio via SignalR → Client carica geometrie 3D
%
% Concetti chiave:
% - Dual-channel orchestration: REST per query, SignalR per comandi
% - User experience: pre-compilazione form, feedback immediato
% - Case-insensitive search: robustezza ricerca
% - Error handling: progetto non trovato, SignalR offline
%
% Diagramma: sequence_2_create_open_project.mmd
% Pagine stimate: 2-3

%----------------------------------------------------------------------------------------
\subsection{Caso d'Uso: Aggiunta Articolo con Varianti}
\label{subsec:aggiunta-articolo}
%----------------------------------------------------------------------------------------

% Flusso completo in 3 fasi:
%
% FASE 1 - Inserimento articolo base:
% - Verifica autenticazione (AutoLoginIfNeeded se necessario)
% - Prepara body JSON con cod, des, cat, model, catmer, dimensioni (l, a, p)
% - POST /muconf/radd → riceve rowId
%
% FASE 2 - Applicazione varianti (se ruleset presente):
% - Step 2.1 GET: POST /muconf/rget per recuperare campo "pars" corrente
% - Step 2.2 MODIFY: applica ruleset modificando pars locale
%   (Esempio: pars["str"] = "c.01" (colore bianco), pars["fin"] = "m.02" (finitura rovere))
% - Step 2.3 SAVE: POST /muconf/rsave con pars modificato
%
% FASE 3 - Notifica Client 3D (se receiverId fornito):
% - CallHubMethodAsync("SendMessage", receiverId, {action: "open", name: projectId})
% - Client riceve notifica → GET /muconf/pget → aggiorna vista 3D
% - Renderizza nuovo articolo con varianti applicate
%
% Concetti chiave:
% - GET-MODIFY-SAVE Pattern: operazione atomica in 3 step
% - Parametric configuration: ruleset per personalizzazione articoli
% - Real-time sync: notifica immediata al client 3D
% - Graceful degradation: articolo inserito anche se varianti falliscono
%
% Diagrammi: diagram_8_sequence_add_article.mmd, sequence_3_add_article_variants.mmd
% Pagine stimate: 2-3

%----------------------------------------------------------------------------------------
\subsection{Caso d'Uso: Comunicazione Bidirezionale}
\label{subsec:comunicazione-bidirezionale}
%----------------------------------------------------------------------------------------

% Flusso full-duplex:
%
% Request (AI → Client):
% - ListElements: costruisce Message {action: "list_elements", params: {catalogo, cerca}}
% - Invio via CallHubMethodAsync → Client esegue ricerca nel catalogo
%
% Response (Client → AI):
% - Client invia risposta: SendMessage con action="list_elements" e params=array risultati
% - Handler ReceiveMessage attivato → salva payload in _lastListElementsPayload
% - GetLastListElements recupera risultati salvati
%
% Gestione disconnessione/riconnessione:
% - Evento Closed: _isConnected = false, logging
% - Auto-reconnect SignalR: tentativi automatici con retry intervals
%
% Concetti chiave:
% - Full-duplex communication: bidirezionalità WebSocket
% - Observer Pattern: callback per messaggi in arrivo
% - Asynchronous request-response: richiesta e risposta disaccoppiate
% - Connection resilience: auto-reconnect per continuità servizio
%
% Diagramma: sequence_4_signalr_bidirectional.mmd
% Pagine stimate: 2

%----------------------------------------------------------------------------------------
\subsection{Caso d'Uso: Gestione Errori}
\label{subsec:gestione-errori}
%----------------------------------------------------------------------------------------

% Scenari di errore gestiti:
%
% 1. Token scaduto (401 Unauthorized):
%    - Detect error 401 → messaggio "Token scaduto, effettua nuovo login"
%    - User experience: hint per azione correttiva
%
% 2. Progetto non trovato:
%    - FirstOrDefault() → null → response con availableProjects (primi 10)
%    - Hint: "Usa GetProjects per lista completa"
%
% 3. SignalR offline:
%    - IsConnected = false → error "SignalR non connesso"
%    - Hint: "Verifica con CheckSignalRStatus()"
%
% 4. Errore validazione API (400 Bad Request):
%    - Parse error response → extract validCategories/availableParams
%    - Hint: "Usa SearchCatalogItems per categorie valide"
%
% 5. Errore applicazione varianti:
%    - Articolo inserito ma rsave fallisce → response parziale
%    - {success: true, variantsApplied: false, variantsError: "..."}
%
% 6. Network timeout:
%    - TaskCanceledException dopo 30s → error "Request timeout"
%    - Hint: "Riprova o verifica connettività"
%
% Concetti chiave:
% - Defensive programming: validazione input, gestione eccezioni
% - Meaningful error messages: descrizione errore + hint azione correttiva
% - Partial success handling: operazioni atomiche con fallback
% - User-friendly feedback: error messages comprensibili per AI Assistant
%
% Diagramma: sequence_5_error_handling.mmd
% Pagine stimate: 2

%----------------------------------------------------------------------------------------
\chapter{Implementazione}
\label{chap:implementazione}
%----------------------------------------------------------------------------------------

% Questo capitolo descrive gli aspetti implementativi concreti del sistema,
% includendo scelte tecnologiche, snippet di codice significativi, configurazioni,
% e dettagli tecnici delle implementazioni dei componenti progettati nel capitolo precedente.

%----------------------------------------------------------------------------------------
\section{Ambiente di Sviluppo e Setup Progetto}
\label{sec:ambiente-sviluppo}
%----------------------------------------------------------------------------------------

% STACK TECNOLOGICO:
% - .NET 8.0 SDK (target framework)
% - C# 12 (linguaggio principale)
% - ASP.NET Core 8.0 (per IwineHub SignalR server)
% - Visual Studio 2022 / VS Code (IDE)
% - Git (version control)
%
% DIPENDENZE NUGET PRINCIPALI:
%
% MCP Server:
% - ModelContextProtocol (SDK MCP ufficiale)
% - Microsoft.AspNetCore.SignalR.Client (client SignalR)
% - System.Text.Json (serializzazione JSON)
% - Microsoft.Extensions.DependencyInjection (DI container)
% - Microsoft.Extensions.Logging (logging)
% - Microsoft.Extensions.Configuration (gestione configurazione)
%
% SignalR Bridge Server:
% - Microsoft.AspNetCore.SignalR (server SignalR)
% - Microsoft.AspNetCore.Authentication.JwtBearer (autenticazione JWT)
% - Microsoft.AspNetCore.Cors (gestione CORS)
%
% Configurator3D Client:
% - @microsoft/signalr (JavaScript/TypeScript client)
% - TypeScript 5.x (type-safety)
%
% STRUTTURA PROGETTO:
% ```
% MarkunoMCP/
% ├── MarkunoApiTools/          # MCP Server principale
% │   ├── Program.cs             # Entry point e configurazione
% │   ├── MarkunoApiTools.cs     # Tool MCP implementation
% │   ├── Models/                # DTO e modelli dati
% │   │   ├── User.cs
% │   │   ├── Project.cs
% │   │   ├── Message.cs
% │   │   └── RuleSetItem.cs
% │   ├── Services/              # Servizi
% │   │   └── SignalRService.cs
% │   └── appsettings.json       # Configurazione
% │
% ├── IwineSignalRServer/        # Bridge SignalR
% │   ├── Program.cs             # ASP.NET Core setup
% │   ├── Hubs/
% │   │   └── IwineHub.cs        # Hub SignalR principale
% │   ├── Interfaces/
% │   │   └── IClient.cs         # Strongly-typed client interface
% │   └── appsettings.json
% │
% └── Configurator3D/            # Client grafico 3D
%     ├── src/
%     │   ├── signalr-client.ts  # Client SignalR
%     │   └── message-handler.ts # Handler messaggi
%     └── package.json
% ```
%
% CONFIGURAZIONE APPSETTINGS.JSON:
% ```json
% {
%   "MarkunoApi": {
%     "BaseUrl": "https://api.markuno.com",
%     "DefaultUser": "admin",
%     "DefaultPassword": "***"
%   },
%   "SignalR": {
%     "HubUrl": "https://localhost:7193",
%     "AllowInsecureCertificates": true
%   },
%   "Logging": {
%     "LogLevel": {
%       "Default": "Information",
%       "Microsoft.AspNetCore.SignalR": "Debug"
%     }
%   }
% }
% ```
%
% SETUP AMBIENTE SVILUPPO:
% 1. Installazione .NET 8.0 SDK
% 2. Clone repository Git
% 3. Restore dipendenze NuGet: dotnet restore
% 4. Configurazione certificati SSL sviluppo: dotnet dev-certs https --trust
% 5. Setup appsettings.Development.json con credenziali locali
% 6. Avvio SignalR server: dotnet run --project IwineSignalRServer
% 7. Avvio MCP server: dotnet run --project MarkunoApiTools
%
% Concetti chiave:
% - Multi-project solution: separazione MCP server e SignalR bridge
% - Configuration management: appsettings per ambiente
% - Dependency management: NuGet per pacchetti .NET
% - SSL/TLS: certificati sviluppo per HTTPS/WSS
%
% Pagine stimate: 3-4

%----------------------------------------------------------------------------------------
\section{Implementazione MCP Server Core}
\label{sec:implementazione-mcp-core}
%----------------------------------------------------------------------------------------

%----------------------------------------------------------------------------------------
\subsection{Bootstrap e Dependency Injection}
\label{subsec:bootstrap-di}
%----------------------------------------------------------------------------------------

% PROGRAM.CS - Entry Point:
%
% ```csharp
% var builder = WebApplication.CreateBuilder(args);
%
% // Caricamento configurazione
% builder.Configuration
%     .AddJsonFile("appsettings.json", optional: false)
%     .AddJsonFile($"appsettings.{builder.Environment.EnvironmentName}.json", optional: true)
%     .AddEnvironmentVariables();
%
% // Registrazione servizi
% builder.Services.AddSingleton<SignalRService>();
% builder.Services.AddHttpClient<MarkunoApiTools>();
% builder.Services.AddLogging(config => {
%     config.AddConsole();
%     config.AddDebug();
% });
%
% // Configurazione MCP
% builder.Services.AddMcp(options => {
%     options.ServerInfo = new ServerInfo {
%         Name = "markuno-mcp-server",
%         Version = "1.0.0"
%     };
% });
%
% var app = builder.Build();
%
% // Avvio SignalR connection in background
% var signalRService = app.Services.GetRequiredService<SignalRService>();
% await signalRService.ConnectAsync();
%
% // Registrazione tool MCP
% app.MapMcpTool<MarkunoApiTools>();
%
% await app.RunAsync();
% ```
%
% DEPENDENCY INJECTION PATTERN:
% - Singleton per SignalRService: istanza condivisa tra tool
% - HttpClient factory: gestione pool connessioni HTTP
% - ILogger injection: logging strutturato per ogni componente
% - IConfiguration injection: accesso configurazione type-safe
%
% LIFECYCLE MANAGEMENT:
% - Application startup: avvio connessione SignalR
% - Graceful shutdown: disconnessione pulita SignalR
% - Background services: keep-alive SignalR connection
%
% Concetti chiave:
% - Dependency Injection Container: Microsoft.Extensions.DI
% - Configuration providers: JSON, environment variables
% - Logging abstraction: ILogger<T> per ogni classe
% - Service lifetimes: Singleton, Scoped, Transient
%
% Pagine stimate: 2-3

%----------------------------------------------------------------------------------------
\subsection{Implementazione Tool MCP}
\label{subsec:implementazione-tool}
%----------------------------------------------------------------------------------------

% STRUTTURA CLASSE MARKUNOAPITOOLS:
%
% ```csharp
% public class MarkunoApiTools : McpToolsBase
% {
%     private readonly HttpClient _httpClient;
%     private readonly SignalRService _signalRService;
%     private readonly ILogger<MarkunoApiTools> _logger;
%     private readonly IConfiguration _config;
%     
%     private static string? _authToken;
%     private static User? _currentUser;
%     
%     public MarkunoApiTools(
%         HttpClient httpClient,
%         SignalRService signalRService,
%         ILogger<MarkunoApiTools> logger,
%         IConfiguration config)
%     {
%         _httpClient = httpClient;
%         _signalRService = signalRService;
%         _logger = logger;
%         _config = config;
%         
%         // Configura HttpClient base address
%         var baseUrl = _config["MarkunoApi:BaseUrl"];
%         _httpClient.BaseAddress = new Uri(baseUrl);
%     }
%     
%     [McpTool("login", "Autentica utente e ottiene token JWT")]
%     public async Task<string> Login(
%         [McpParameter("username")] string? username = null,
%         [McpParameter("password")] string? password = null)
%     {
%         // Usa credenziali da config se non fornite
%         username ??= _config["MarkunoApi:DefaultUser"];
%         password ??= _config["MarkunoApi:DefaultPassword"];
%         
%         var loginRequest = new { name = username, password };
%         var response = await _httpClient.PostAsJsonAsync("/api/login", loginRequest);
%         
%         if (!response.IsSuccessStatusCode)
%         {
%             return JsonSerializer.Serialize(new {
%                 success = false,
%                 error = "Login fallito",
%                 statusCode = (int)response.StatusCode
%             });
%         }
%         
%         var loginResponse = await response.Content.ReadFromJsonAsync<LoginResponse>();
%         _authToken = loginResponse?.Data?.User?.Token;
%         _currentUser = loginResponse?.Data?.User;
%         
%         _logger.LogInformation("Login effettuato per utente {Username}", username);
%         
%         return JsonSerializer.Serialize(new {
%             success = true,
%             username = _currentUser?.Name,
%             userId = _currentUser?.Id,
%             level = _currentUser?.Level
%         });
%     }
%     
%     private async Task EnsureAuthenticatedAsync()
%     {
%         if (string.IsNullOrEmpty(_authToken))
%         {
%             await Login();
%         }
%     }
%     
%     private void AddAuthHeader()
%     {
%         if (!string.IsNullOrEmpty(_authToken))
%         {
%             _httpClient.DefaultRequestHeaders.Authorization = 
%                 new AuthenticationHeaderValue("Bearer", _authToken);
%         }
%     }
% }
% ```
%
% ATTRIBUTI MCP:
% - [McpTool]: marca metodi come tool esposti all'AI
% - [McpParameter]: definisce parametri con descrizione
% - Metadata per discovery automatico tool
%
% GESTIONE AUTENTICAZIONE:
% - Token JWT in variabile statica (_authToken)
% - User corrente in variabile statica (_currentUser)
% - Auto-login con credenziali default
% - Header Authorization automatico per richieste HTTP
%
% PATTERN ASYNC/AWAIT:
% - Tutti i metodi tool sono async Task<string>
% - HttpClient async per chiamate REST API
% - SignalRService async per comunicazione real-time
%
% Concetti chiave:
% - Attribute-based programming: metadata per tool MCP
% - Static state: token condiviso tra invocazioni tool
% - Async programming: operazioni I/O non bloccanti
% - HttpClient patterns: gestione pool connessioni
%
% Pagine stimate: 3-4

%----------------------------------------------------------------------------------------
\subsection{Implementazione Tool Complessi}
\label{subsec:tool-complessi}
%----------------------------------------------------------------------------------------

% ESEMPIO: IMPLEMENTAZIONE AddArticle CON PATTERN GET-MODIFY-SAVE
%
% ```csharp
% [McpTool("add_article", "Aggiunge articolo con varianti al progetto")]
% public async Task<string> AddArticle(
%     [McpParameter("projectId")] string projectId,
%     [McpParameter("cod")] string cod,
%     [McpParameter("des")] string des,
%     [McpParameter("cat")] string cat,
%     [McpParameter("model")] string model,
%     [McpParameter("catmer")] string catmer,
%     [McpParameter("l")] int l,
%     [McpParameter("a")] int a,
%     [McpParameter("p")] int p,
%     [McpParameter("ruleset")] List<RuleSetItem>? ruleset = null,
%     [McpParameter("receiverId")] string? receiverId = null)
% {
%     await EnsureAuthenticatedAsync();
%     AddAuthHeader();
%     
%     // FASE 1: Inserimento articolo base
%     var articleData = new {
%         id = projectId,
%         cod, des, cat, model, catmer,
%         l, a, p,
%         tipo = "a",
%         ruleset = new List<object>(), // Vuoto per ora
%         note = "",
%         rule = ""
%     };
%     
%     var addResponse = await _httpClient.PostAsJsonAsync("/muconf/radd", articleData);
%     if (!addResponse.IsSuccessStatusCode)
%     {
%         return ErrorResponse("Errore inserimento articolo", addResponse.StatusCode);
%     }
%     
%     var addResult = await addResponse.Content.ReadFromJsonAsync<ApiResponse>();
%     var rowId = addResult?.Data?.Data; // Estrai rowId
%     
%     _logger.LogInformation("Articolo base inserito, rowId={RowId}", rowId);
%     
%     // FASE 2: Applicazione varianti (se presenti)
%     bool variantsApplied = false;
%     if (ruleset != null && ruleset.Count > 0)
%     {
%         // Step 2.1: GET - Recupera stato corrente
%         var getRequest = new {
%             id = projectId,
%             idr = rowId,
%             noeval = true
%         };
%         var getResponse = await _httpClient.PostAsJsonAsync("/muconf/rget", getRequest);
%         var getResult = await getResponse.Content.ReadFromJsonAsync<ArticleResponse>();
%         var pars = getResult?.Data?.Pars ?? new Dictionary<string, string>();
%         
%         // Step 2.2: MODIFY - Applica ruleset
%         foreach (var rule in ruleset)
%         {
%             pars[rule.Cod] = rule.Opz;
%             _logger.LogDebug("Applicata regola: {Cod}={Opz}", rule.Cod, rule.Opz);
%         }
%         
%         // Step 2.3: SAVE - Salva modifiche
%         var saveRequest = new {
%             id = projectId,
%             idr = rowId,
%             pars
%         };
%         var saveResponse = await _httpClient.PostAsJsonAsync("/muconf/rsave", saveRequest);
%         variantsApplied = saveResponse.IsSuccessStatusCode;
%         
%         _logger.LogInformation("Varianti applicate: {Count} regole", ruleset.Count);
%     }
%     
%     // FASE 3: Notifica client 3D (se receiverId fornito)
%     bool notified = false;
%     if (!string.IsNullOrEmpty(receiverId))
%     {
%         var message = new Message {
%             Action = "open",
%             Name = projectId,
%             Route = $"/direct/{receiverId}",
%             Params = new { projectId, rowId }
%         };
%         
%         notified = await _signalRService.CallHubMethodAsync(
%             "SendMessage", receiverId, message);
%             
%         _logger.LogInformation("Client 3D notificato: {Notified}", notified);
%     }
%     
%     // Risposta completa
%     return JsonSerializer.Serialize(new {
%         success = true,
%         rowId,
%         article = new { cod, des },
%         variantsApplied,
%         variantsCount = ruleset?.Count ?? 0,
%         notified
%     });
% }
% ```
%
% GESTIONE ERRORI:
% - Try-catch per eccezioni HTTP
% - Validazione response status codes
% - Logging strutturato per debugging
% - Partial success: articolo inserito anche se varianti falliscono
%
% PATTERN IMPLEMENTATIVI:
% - GET-MODIFY-SAVE: lettura → modifica → scrittura
% - Fluent chaining: operazioni sequenziali async
% - Dictionary manipulation: modifica campo pars
% - Conditional execution: varianti e notifica opzionali
%
% Concetti chiave:
% - Complex workflows: orchestrazione multiple API calls
% - Error resilience: partial success handling
% - Structured logging: tracciamento operazioni
% - Async coordination: await multiple operations
%
% Pagine stimate: 3-4

%----------------------------------------------------------------------------------------
\section{Implementazione SignalR Service}
\label{sec:implementazione-signalr-service}
%----------------------------------------------------------------------------------------

%----------------------------------------------------------------------------------------
\subsection{Classe SignalRService e Connection Management}
\label{subsec:signalr-service-class}
%----------------------------------------------------------------------------------------

% STRUTTURA CLASSE:
%
% ```csharp
% public class SignalRService : IAsyncDisposable
% {
%     private HubConnection? _hubConnection;
%     private readonly ILogger<SignalRService> _logger;
%     private readonly IConfiguration _config;
%     private string _configuredUrl;
%     private bool _isConnected;
%     private readonly List<Action<string, object>> _receiveHandlers = new();
%     private readonly object _lastListLock = new();
%     private string? _lastListElementsPayload;
%     
%     public SignalRService(ILogger<SignalRService> logger, IConfiguration config)
%     {
%         _logger = logger;
%         _config = config;
%         _configuredUrl = _config["SignalR:HubUrl"] ?? "https://localhost:7193";
%     }
%     
%     public bool IsConnected => _isConnected && 
%                                _hubConnection?.State == HubConnectionState.Connected;
%     
%     public string? ConnectionId => _hubConnection?.ConnectionId;
% }
% ```
%
% METODO ConnectAsync CON RETRY LOGIC:
%
% ```csharp
% public async Task<bool> ConnectAsync()
% {
%     if (IsConnected) return true;
%     
%     var urls = new[] {
%         _configuredUrl,
%         $"{_configuredUrl}/hub",
%         $"{_configuredUrl}/configuratorHub"
%     };
%     
%     foreach (var url in urls)
%     {
%         try
%         {
%             _logger.LogInformation("Tentativo connessione a {Url}", url);
%             
%             if (await TryBuildAndStartConnectionAsync(url))
%             {
%                 _isConnected = true;
%                 _logger.LogInformation("Connesso con successo, ConnectionId={Id}", ConnectionId);
%                 return true;
%             }
%         }
%         catch (Exception ex)
%         {
%             _logger.LogWarning(ex, "Fallito tentativo connessione a {Url}", url);
%         }
%     }
%     
%     _logger.LogError("Tutti i tentativi di connessione falliti");
%     return false;
% }
%
% private async Task<bool> TryBuildAndStartConnectionAsync(string url)
% {
%     var allowInsecure = _config.GetValue<bool>("SignalR:AllowInsecureCertificates");
%     
%     var builder = new HubConnectionBuilder()
%         .WithUrl(url, options => {
%             if (allowInsecure)
%             {
%                 options.HttpMessageHandlerFactory = handler => {
%                     if (handler is HttpClientHandler clientHandler)
%                     {
%                         clientHandler.ServerCertificateCustomValidationCallback = 
%                             (message, cert, chain, errors) => true;
%                     }
%                     return handler;
%                 };
%             }
%         })
%         .WithAutomaticReconnect(new[] {
%             TimeSpan.Zero,      // Tentativo immediato
%             TimeSpan.FromSeconds(2),
%             TimeSpan.FromSeconds(5),
%             TimeSpan.FromSeconds(10)
%         })
%         .ConfigureLogging(logging => {
%             logging.SetMinimumLevel(LogLevel.Debug);
%         })
%         .Build();
%     
%     // Registra event handlers
%     builder.Closed += async (error) => {
%         _isConnected = false;
%         _logger.LogWarning("Connessione SignalR chiusa: {Error}", error?.Message);
%         await Task.CompletedTask;
%     };
%     
%     builder.Reconnecting += (error) => {
%         _logger.LogInformation("Tentativo riconnessione SignalR");
%         return Task.CompletedTask;
%     };
%     
%     builder.Reconnected += (connectionId) => {
%         _isConnected = true;
%         _logger.LogInformation("Riconnessione riuscita, nuovo ConnectionId={Id}", connectionId);
%         return Task.CompletedTask;
%     };
%     
%     // Registra message handlers
%     RegisterReceiveHandlers(builder);
%     
%     await builder.StartAsync();
%     _hubConnection = builder;
%     return true;
% }
% ```
%
% GESTIONE RICONNESSIONE:
% - WithAutomaticReconnect: backoff esponenziale (0s, 2s, 5s, 10s)
% - Event handlers: Closed, Reconnecting, Reconnected
% - State tracking: _isConnected flag aggiornato
% - Logging: tracciamento tutti gli eventi lifecycle
%
% MULTIPLE ENDPOINT FALLBACK:
% - Prova URL base configurato
% - Prova URL + /hub (convenzione SignalR)
% - Prova URL + /configuratorHub (endpoint custom)
% - Loop su array con try-catch per resilienza
%
% CERTIFICATI SSL SVILUPPO:
% - ServerCertificateCustomValidationCallback per self-signed
% - Configurabile via appsettings (AllowInsecureCertificates)
% - Solo per ambiente sviluppo, disabilitato in produzione
%
% Concetti chiave:
% - Builder pattern: configurazione fluent HubConnection
% - Retry logic: tentativi multipli con backoff
% - Event-driven: handlers per lifecycle events
% - Configuration-driven: URL e certificati da appsettings
%
% Pagine stimate: 3-4

%----------------------------------------------------------------------------------------
\subsection{Invio e Ricezione Messaggi}
\label{subsec:invio-ricezione-messaggi}
%----------------------------------------------------------------------------------------

% INVIO MESSAGGI AL SERVER:
%
% ```csharp
% public async Task<bool> CallHubMethodAsync(string methodName, params object[] args)
% {
%     if (!IsConnected)
%     {
%         _logger.LogWarning("Tentativo invio messaggio senza connessione attiva");
%         return false;
%     }
%     
%     try
%     {
%         await _hubConnection!.InvokeCoreAsync(methodName, args);
%         _logger.LogDebug("Invocato metodo {Method} con {ArgCount} argomenti", 
%             methodName, args.Length);
%         return true;
%     }
%     catch (Exception ex)
%     {
%         _logger.LogError(ex, "Errore invocazione metodo {Method}", methodName);
%         return false;
%     }
% }
%
% public async Task<bool> SendCommandAsync(string receiverId, Message message)
% {
%     return await CallHubMethodAsync("SendMessage", receiverId, message);
% }
% ```
%
% RICEZIONE MESSAGGI DAL SERVER:
%
% ```csharp
% private void RegisterReceiveHandlers(HubConnection connection)
% {
%     // Handler per messaggi diretti
%     connection.On<string, object>("ReceiveMessage", (senderId, message) => {
%         _logger.LogInformation("Ricevuto messaggio da {Sender}", senderId);
%         
%         // Invoca tutti gli handler registrati
%         foreach (var handler in _receiveHandlers)
%         {
%             try
%             {
%                 handler(senderId, message);
%             }
%             catch (Exception ex)
%             {
%                 _logger.LogError(ex, "Errore in message handler");
%             }
%         }
%     });
%     
%     // Handler per messaggi generici
%     connection.On<object>("GetMessage", (message) => {
%         _logger.LogInformation("Ricevuto GetMessage: {Message}", message);
%     });
%     
%     _logger.LogDebug("Handler messaggi registrati");
% }
%
% public void OnReceiveMessage(Action<string, object> handler)
% {
%     _receiveHandlers.Add(handler);
%     _logger.LogDebug("Registrato nuovo handler, totale={Count}", _receiveHandlers.Count);
% }
% ```
%
% HANDLER SPECIFICO PER LIST_ELEMENTS:
%
% ```csharp
% private void EnsureListElementsHandlerRegistered()
% {
%     if (_receiveHandlers.Any(h => h.Method.Name.Contains("ListElements")))
%         return;
%     
%     OnReceiveMessage((senderId, message) => {
%         try
%         {
%             var messageObj = JsonSerializer.Deserialize<Message>(
%                 message.ToString() ?? "{}");
%             
%             if (messageObj?.Action == "list_elements")
%             {
%                 lock (_lastListLock)
%                 {
%                     _lastListElementsPayload = JsonSerializer.Serialize(messageObj.Params);
%                 }
%                 _logger.LogInformation("Salvato payload list_elements");
%             }
%         }
%         catch (Exception ex)
%         {
%             _logger.LogError(ex, "Errore parsing message list_elements");
%         }
%     });
% }
%
% public string? GetLastListElements()
% {
%     lock (_lastListLock)
%     {
%         return _lastListElementsPayload;
%     }
% }
% ```
%
% PATTERN OBSERVER:
% - List di Action<string, object> per handler multipli
% - OnReceiveMessage registra callback
% - RegisterReceiveHandlers invoca tutti i callback
% - Thread-safe con try-catch per ogni handler
%
% GESTIONE STATE:
% - _lastListElementsPayload: cache ultimo payload ricevuto
% - Lock per thread-safety (_lastListLock)
% - Getter pubblico per recupero asincrono
%
% SERIALIZZAZIONE/DESERIALIZZAZIONE:
% - SignalR serializza automaticamente Message in JSON
% - Deserializzazione manuale per processing specifico
% - System.Text.Json per performance
%
% Concetti chiave:
% - Observer Pattern: multiple handlers per eventi
% - Thread-safety: lock per accesso concorrente
% - Type-safe invocation: InvokeCoreAsync con params
% - Error isolation: try-catch per ogni handler
%
% Pagine stimate: 3-4

%----------------------------------------------------------------------------------------
\section{Implementazione Hub (SignalR Server)}
\label{sec:implementazione-iwine-hub}
%----------------------------------------------------------------------------------------

% CLASSE HUB PRINCIPALE:
%
% ```csharp
% public class IwineHub : Hub<IClient>
% {
%     private readonly ILogger<IwineHub> _logger;
%     
%     public IwineHub(ILogger<IwineHub> logger)
%     {
%         _logger = logger;
%     }
%     
%     public override async Task OnConnectedAsync()
%     {
%         var connectionId = Context.ConnectionId;
%         _logger.LogInformation("Client connesso: {ConnectionId}", connectionId);
%         
%         // Invia ConnectionId al client
%         await Clients.Caller.GetConnectionId(connectionId);
%         
%         await base.OnConnectedAsync();
%     }
%     
%     public override async Task OnDisconnectedAsync(Exception? exception)
%     {
%         var connectionId = Context.ConnectionId;
%         _logger.LogInformation("Client disconnesso: {ConnectionId}, Reason: {Reason}", 
%             connectionId, exception?.Message);
%         
%         await base.OnDisconnectedAsync(exception);
%     }
%     
%     public async Task SendMessage(Message message)
%     {
%         var senderId = Context.ConnectionId;
%         _logger.LogInformation("SendMessage da {Sender}, Action={Action}, Route={Route}", 
%             senderId, message.Action, message.Route);
%         
%         try
%         {
%             // Validazione messaggio
%             if (string.IsNullOrEmpty(message.Action))
%             {
%                 throw new HubException("Action è obbligatoria");
%             }
%             
%             // Routing basato su Route
%             if (message.Route?.StartsWith("/broadcast") == true)
%             {
%                 // Broadcasting a tutti
%                 await Clients.All.GetMessage(message);
%                 _logger.LogDebug("Messaggio broadcast a tutti i client");
%             }
%             else if (message.Params is JsonElement paramsElement && 
%                      paramsElement.TryGetProperty("receiverId", out var receiverIdProp))
%             {
%                 // Point-to-point a client specifico
%                 var receiverId = receiverIdProp.GetString();
%                 await Clients.Client(receiverId!).GetMessage(message);
%                 _logger.LogDebug("Messaggio inviato a {Receiver}", receiverId);
%             }
%             else
%             {
%                 // Default: broadcast
%                 await Clients.All.GetMessage(message);
%             }
%         }
%         catch (Exception ex)
%         {
%             _logger.LogError(ex, "Errore processing messaggio");
%             throw new HubException($"Errore processing messaggio: {ex.Message}");
%         }
%     }
%     
%     public async Task SendConnectionId(string receiverId, string senderId)
%     {
%         _logger.LogInformation("SendConnectionId: {Sender} → {Receiver}", 
%             senderId, receiverId);
%         
%         try
%         {
%             await Clients.Client(receiverId).GetConnectionId(senderId);
%         }
%         catch (Exception ex)
%         {
%             _logger.LogError(ex, "Errore invio ConnectionId");
%             throw new HubException($"Client {receiverId} non trovato");
%         }
%     }
% }
% ```
%
% INTERFACCIA STRONGLY-TYPED:
%
% ```csharp
% public interface IClient
% {
%     Task GetMessage(Message message);
%     Task GetConnectionId(string connectionId);
% }
% ```
%
% CONFIGURAZIONE ASP.NET CORE:
%
% ```csharp
% // Program.cs del SignalR Server
% var builder = WebApplication.CreateBuilder(args);
%
% // Aggiungi SignalR
% builder.Services.AddSignalR(options => {
%     options.EnableDetailedErrors = true;
%     options.KeepAliveInterval = TimeSpan.FromSeconds(15);
%     options.ClientTimeoutInterval = TimeSpan.FromSeconds(30);
% });
%
% // Aggiungi CORS
% builder.Services.AddCors(options => {
%     options.AddPolicy("AllowAll", policy => {
%         policy.AllowAnyOrigin()
%               .AllowAnyMethod()
%               .AllowAnyHeader();
%     });
% });
%
% var app = builder.Build();
%
% app.UseCors("AllowAll");
% app.UseRouting();
%
% // Mappa Hub SignalR
% app.MapHub<IwineHub>("/configuratorHub");
%
% app.Run();
% ```
%
% ROUTING MESSAGGI:
% - Pattern matching su message.Route
% - Clients.All per broadcasting
% - Clients.Client(id) per point-to-point
% - Clients.Caller per risposta a mittente
% - Clients.Group(name) per gruppi (se implementato)
%
% VALIDAZIONE:
% - Controllo message.Action non vuoto
% - Try-catch per errori processing
% - HubException per errori client-friendly
% - Logging strutturato per debugging
%
% STRONGLY-TYPED HUB:
% - Hub<IClient> per type-safety
% - Compilazione verifica metodi IClient
% - IntelliSense per metodi client
% - Refactoring safe
%
% Concetti chiave:
% - Hub as controller: routing e orchestrazione
% - Strongly-typed clients: type-safety end-to-end
% - Lifecycle hooks: OnConnected/OnDisconnected
% - CORS configuration: cross-origin support
%
% Pagine stimate: 3-4

%----------------------------------------------------------------------------------------
\section{Implementazione Client Configurator3D}
\label{sec:implementazione-client-3d}
%----------------------------------------------------------------------------------------

% CLIENT TYPESCRIPT SIGNALR:
%
% ```typescript
% import * as signalR from "@microsoft/signalr";
%
% export class SignalRClient {
%     private connection: signalR.HubConnection;
%     private messageHandlers: Map<string, (message: Message) => void>;
%     
%     constructor(hubUrl: string) {
%         this.messageHandlers = new Map();
%         
%         this.connection = new signalR.HubConnectionBuilder()
%             .withUrl(hubUrl)
%             .withAutomaticReconnect([0, 2000, 5000, 10000])
%             .configureLogging(signalR.LogLevel.Information)
%             .build();
%         
%         this.setupEventHandlers();
%     }
%     
%     private setupEventHandlers(): void {
%         // Handler ricezione messaggi
%         this.connection.on("GetMessage", (message: Message) => {
%             console.log("Ricevuto messaggio:", message);
%             this.handleMessage(message);
%         });
%         
%         // Handler ricezione ConnectionId
%         this.connection.on("GetConnectionId", (connectionId: string) => {
%             console.log("Ricevuto ConnectionId:", connectionId);
%             localStorage.setItem("signalr-connection-id", connectionId);
%         });
%         
%         // Lifecycle events
%         this.connection.onclose((error) => {
%             console.warn("Connessione chiusa:", error);
%         });
%         
%         this.connection.onreconnecting((error) => {
%             console.info("Tentativo riconnessione...");
%         });
%         
%         this.connection.onreconnected((connectionId) => {
%             console.info("Riconnesso, nuovo ID:", connectionId);
%         });
%     }
%     
%     async start(): Promise<void> {
%         try {
%             await this.connection.start();
%             console.log("SignalR connesso, ID:", this.connection.connectionId);
%         } catch (error) {
%             console.error("Errore connessione SignalR:", error);
%             setTimeout(() => this.start(), 5000); // Retry dopo 5s
%         }
%     }
%     
%     registerHandler(action: string, handler: (message: Message) => void): void {
%         this.messageHandlers.set(action, handler);
%     }
%     
%     private handleMessage(message: Message): void {
%         const handler = this.messageHandlers.get(message.Action);
%         if (handler) {
%             handler(message);
%         } else {
%             console.warn("Nessun handler per action:", message.Action);
%         }
%     }
%     
%     async sendMessage(message: Message): Promise<void> {
%         await this.connection.invoke("SendMessage", message);
%     }
% }
% ```
%
% MESSAGE HANDLER SPECIFICI:
%
% ```typescript
% export class MessageHandler {
%     private signalRClient: SignalRClient;
%     private configurator: Configurator3D;
%     
%     constructor(signalRClient: SignalRClient, configurator: Configurator3D) {
%         this.signalRClient = signalRClient;
%         this.configurator = configurator;
%         
%         this.registerHandlers();
%     }
%     
%     private registerHandlers(): void {
%         // Handler per "open"
%         this.signalRClient.registerHandler("open", async (message) => {
%             const projectId = message.Name;
%             console.log("Comando OPEN progetto:", projectId);
%             
%             // Carica progetto nel configurator 3D
%             const projectData = await this.fetchProjectData(projectId);
%             await this.configurator.loadProject(projectData);
%             
%             // Invia conferma
%             await this.sendAck(message, { loaded: true });
%         });
%         
%         // Handler per "create"
%         this.signalRClient.registerHandler("create", async (message) => {
%             const params = message.Params as CreateProjectParams;
%             console.log("Comando CREATE progetto:", params);
%             
%             // Mostra dialog creazione con dati pre-compilati
%             this.configurator.showCreateDialog({
%                 description: params.des,
%                 notes: params.note,
%                 autoOpen: params.open
%             });
%         });
%         
%         // Handler per "list_elements"
%         this.signalRClient.registerHandler("list_elements", async (message) => {
%             const params = message.Params as ListElementsParams;
%             console.log("Richiesta LIST_ELEMENTS:", params);
%             
%             // Cerca nel catalogo locale
%             const results = await this.configurator.searchCatalog(
%                 params.catalogo,
%                 params.cerca
%             );
%             
%             // Invia risultati al server
%             await this.signalRClient.sendMessage({
%                 Action: "list_elements",
%                 Name: "response",
%                 Route: "/response",
%                 Params: results
%             });
%         });
%     }
%     
%     private async fetchProjectData(projectId: string): Promise<ProjectData> {
%         const response = await fetch(`/api/projects/${projectId}`);
%         return await response.json();
%     }
%     
%     private async sendAck(originalMessage: Message, data: any): Promise<void> {
%         await this.signalRClient.sendMessage({
%             Action: "ack",
%             Name: originalMessage.Action,
%             Route: "/ack",
%             Params: data
%         });
%     }
% }
% ```
%
% INTEGRAZIONE CON CONFIGURATOR 3D:
% - SignalRClient: gestione connessione e messaggi
% - MessageHandler: dispatch messaggi ad azioni specifiche
% - Configurator3D: interfaccia per operazioni 3D (loadProject, showCreateDialog, searchCatalog)
% - Comunicazione bidirezionale: client può rispondere con sendMessage
%
% PATTERN IMPLEMENTATIVI:
% - Map<string, handler>: dispatch dinamico per action
% - Async/await: operazioni asincrone (fetch, invoke)
% - Lifecycle management: setup in constructor, cleanup in destroy
% - Error handling: try-catch con logging
%
% Concetti chiave:
% - TypeScript: type-safety lato client
% - SignalR JS SDK: client WebSocket JavaScript
% - Handler registration: pattern observer client-side
% - Bidirectional communication: client può inviare/ricevere
%
% Pagine stimate: 3-4

%----------------------------------------------------------------------------------------
\section{Gestione Configurazione e Sicurezza}
\label{sec:configurazione-sicurezza}
%----------------------------------------------------------------------------------------

% GESTIONE APPSETTINGS PER AMBIENTE:
%
% appsettings.json (base):
% ```json
% {
%   "MarkunoApi": {
%     "BaseUrl": "https://api.markuno.com"
%   },
%   "SignalR": {
%     "HubUrl": "https://signalr.markuno.com",
%     "AllowInsecureCertificates": false
%   },
%   "Logging": {
%     "LogLevel": {
%       "Default": "Information"
%     }
%   }
% }
% ```
%
% appsettings.Development.json:
% ```json
% {
%   "MarkunoApi": {
%     "BaseUrl": "https://localhost:5001",
%     "DefaultUser": "dev-user",
%     "DefaultPassword": "dev-password"
%   },
%   "SignalR": {
%     "HubUrl": "https://localhost:7193",
%     "AllowInsecureCertificates": true
%   },
%   "Logging": {
%     "LogLevel": {
%       "Default": "Debug",
%       "Microsoft.AspNetCore.SignalR": "Trace"
%     }
%   }
% }
% ```
%
% SECRETS MANAGEMENT:
% - User Secrets per sviluppo locale
% - dotnet user-secrets init
% - dotnet user-secrets set "MarkunoApi:DefaultPassword" "secret"
% - Non committare credenziali in Git
% - Azure Key Vault per produzione
%
% CONFIGURAZIONE SSL/TLS:
%
% ```csharp
% // Sviluppo: Trust certificati self-signed
% if (builder.Environment.IsDevelopment())
% {
%     builder.Services.AddHttpClient()
%         .ConfigurePrimaryHttpMessageHandler(() => new HttpClientHandler {
%             ServerCertificateCustomValidationCallback = 
%                 HttpClientHandler.DangerousAcceptAnyServerCertificateValidator
%         });
% }
% ```
%
% AUTENTICAZIONE JWT:
%
% ```csharp
% // IwineHub authentication
% builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
%     .AddJwtBearer(options => {
%         options.Authority = "https://identity-server.com";
%         options.Audience = "iwine-hub";
%         
%         // Per SignalR
%         options.Events = new JwtBearerEvents {
%             OnMessageReceived = context => {
%                 var accessToken = context.Request.Query["access_token"];
%                 var path = context.HttpContext.Request.Path;
%                 
%                 if (!string.IsNullOrEmpty(accessToken) && 
%                     path.StartsWithSegments("/configuratorHub"))
%                 {
%                     context.Token = accessToken;
%                 }
%                 return Task.CompletedTask;
%             }
%         };
%     });
% ```
%
% CORS CONFIGURATION:
%
% ```csharp
% builder.Services.AddCors(options => {
%     options.AddPolicy("Production", policy => {
%         policy.WithOrigins(
%             "https://configurator.markuno.com",
%             "https://app.markuno.com"
%         )
%         .AllowAnyMethod()
%         .AllowAnyHeader()
%         .AllowCredentials(); // Per SignalR cookies
%     });
%     
%     options.AddPolicy("Development", policy => {
%         policy.AllowAnyOrigin()
%               .AllowAnyMethod()
%               .AllowAnyHeader();
%     });
% });
%
% var corsPolicy = builder.Environment.IsDevelopment() 
%     ? "Development" 
%     : "Production";
% app.UseCors(corsPolicy);
% ```
%
% BEST PRACTICES SICUREZZA:
% - Credenziali mai hardcoded
% - HTTPS/WSS obbligatorio in produzione
% - JWT con expiration breve (15-30 min)
% - Refresh token per sessioni lunghe
% - CORS policy restrittive in produzione
% - Input validation per tutti i parametri
% - Rate limiting per prevenire abuse
%
% Concetti chiave:
% - Configuration hierarchy: base → environment → secrets
% - Environment-specific settings: Development vs Production
% - JWT Bearer authentication: standard OAuth 2.0
% - CORS policies: security cross-origin
% - SSL/TLS: encryption in transit
%
% Pagine stimate: 3-4

%----------------------------------------------------------------------------------------

\chapter{Conclusioni e sviluppi futuri}
% BIBLIOGRAPHY
%----------------------------------------------------------------------------------------

\backmatter

\nocite{*} % Remove this as soon as you have the first citation

\bibliographystyle{alpha}
\bibliography{bibliography}

\begin{acknowledgements} % this is optional
Optional. Max 1 page.
\end{acknowledgements}

\end{document}
